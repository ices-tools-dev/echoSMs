 rem	B1.5.1 opt pred filt opBC  REM	PORGRAM READS A FILE, COMPUTES AUTOCORRELATION, FILTERREM	COEFFICIENTS, AND THEN DOES OPTIMUM WEINER FILTER REM	OPERATION ON THE SIGNAL X( n). THE RESULT IS THE ERROR ER(n).	DIM X(1100),P(1100),ER(1100)	DIM R(100),G(50),GI(50),FZ(50),FZ1(50),AZ(50),AZ1(50)	REM     SCREEN IS 492 BY 300 PIXELS		X0%=20 :Y0%=20: XL%= 480: YL%=280				REM ZERO ALL ARRAYS		for n = 0 to 1100	     X(n) = 0: P(n) = 0: ER(n) = 0	next n		for n= 0 to 100	    R(n) = 0	next n		for n = 0 to 50	    G(n) = 0: AZ(n) = 0: Az1(n) = 0	    GI(n) = 0: FZ(n) = 0: FZ1(n) = 0	next n	REM	READ FILE		print"read signal file for input"	print"give file name":input n1$	open n1$ for input as #1		input #1, nt		FOR n = 0 TO nt	    input #1, X(n)	NEXT n	close #1		REM 	GOTO SUBROUTINE TO CALCULATE AUTOCORRELATION FUNCTION	PRINT " INPUT MAXIMUM TIME STEP FOR AUTOCORRELATION = ";:INPUT j1	GOSUB 2000	REM 	GOTO SUBROUTINE TO CALCULATE PREDICTION FILTER COEFFICIENTS.100	PRINT "MAX LENGTH CORRELATION =";j1	PRINT  TAB( 5);"INDICES 0 TO Li. Li=";: INPUT Li	PRINT "INPUT PREDICT AHEAD TIME STEPS=";: INPUT pa	GOSUB 3000 	REM 	GOTO SUBROUTINE FOR PREDICTION FILTER OPERATION	GOSUB 4000	REM 	DISPLAY EVERYTHING	GOSUB 5000		END 	2000 	REM AUTOCORRELATIONREM  	CALC AUTO CORREL, EQ.(B.85)	PRINT " n      R(n)" 	FOR j = 0 TO j1 	    sum = 0	    	    FOR n = 0 TO nt - j	        sum = sum + X(n) * X(n + j)	    NEXT n	     	    R(j) = sum	NEXT j		norm = R(0)		FOR j = 0 TO j1	    R(j) = R(j) / norm	NEXT j		j2 =INT( j1 / 2 + .5)	FOR j = 0 TO j2	    PRINT j; TAB(6); R(j);TAB(20);j2 + j;TAB(26); R(j2+j)	NEXT j	REM  	END AUTO CORRELATION CALC	PRINT "PAUSE:ANY KEY TO CONTINUE"	INPUT Q$		RETURN3000	REM PREDICTION FILTERS USING EUREKA	M = 0:N = 1: REM  ARRAYS 0 AND 1 IN EUREKA SUBROUTINE	REM	PUT R(j+pa) in the array G(j). R(j+pa) is the correlation the signal and the REM	desired output.	for j = 0 to Li +pa	    G(j) = R(j + pa)	next j REM  	L=0 TERM IS FIRST. 	AZ(0) = 1	FZ(0) = G(0) / R(0)	AL = R(0)	GM = FZ(0) * R(1)	BT = R(1)	K =  - BT / AL		FOR L = 1 TO Li	    AZ1(0) = AZ(O)	    	        FOR J = 1 TO L - 1	            AZ1(J) = AZ(J) + K * AZ(L - J)	        NEXT J			    AZ1(L) = K * AZ(0)	    AL1 = AL + K * BT	    REM  FOR BETA	    BT1 = 0	    	    FOR J = 0 TO L	        BT1 = BT1 + AZ1(J) * R(L + 1 - J)	    NEXT J	    	    K1 =  - BT1 / AL1	    Q = (G(L) - GM) / AL1	    	    FOR J = 0 TO L - 1	        FZ1(J) = FZ(J) + Q * AZ1(L - J)	    NEXT J	    	    FZ1(L) = Q * AZ1(0)REM  	    GAMMA	    GM1 = 0	                FOR J = 0 TO L                GM1 = GM1 + FZ1(J) * R(L + 1 - J)            NEXT J	    REM   	SLIDE COEFFICIENTS	    FOR J = 0 TO L	        AZ(J) = AZ1(J)                FZ(J) = FZ1(J)	    NEXT J	    REM  	SLIDE	    AL = AL1	    BT = BT1	    K = K1	    GM = GM1REM  	REPEAT FOR NEW L	NEXT L  	print "filter done" 	RETURN : REM THE PREDICTION FILTER OPERATION IS NEXT. 	4000	REM DO PREDICTION AND CALCULATE ERROR	for n = 0 to PA	    P(n) = X(n)	next n		for n = pa to nt	    sum = 0	    for j = 0 to Li	        FX = 0	        k = n-j		if k >= 0 then FX = FZ(j) * X(k)		sum = sum + FX	    next j	    ER(n+pa) = X(n+pa) - sum	    P(n + pa) = sum	next n	rem 	Prediction operation is finished.	RETURN5000 	REM DISPLAYrem	plot signals		YS = (YL%-Y0%) / 5        TSC = (XL%-XO%) / (nt+1)		print"input amplitude factors for X(n), P(n), E(n) and R(j)";	input xamp, pamp,eamp, ramp		xmp = xamp*YS: pmp = YS*pamp: emp = eamp*YS: rmp=ramp*YS		cls		for n = 0 to nt	    T% = int (n * TSC +X0%)	    T1% = int ((n+1) * TSC +X0%)	    YX% = int (YS - xmp * X(n))            YX1% = int (YS - xmp * X(n+1))	    LINE (T%,YX%) - (T1%,YX1%)	next n		for n = 0 to nt	    T% = int (n * TSC +X0%)	    T1% = int ((n+1) * TSC +X0%)	   	    	    YP% = int (2 * YS - pmp * P(n))            YP1% = int (2 * YS - pmp * P(n+1))	    LINE (T%,YP%) - (T1%,YP1%)	next n		for n = 0 to nt	    T% = int (n * TSC +X0%)	    T1% = int ((n+1) * TSC +X0%)	   	   	     	    YE% = int (3 * YS - emp * ER(n))            YE1% = int (3 * YS - emp * ER(n+1))	    LINE (T%,YE%) - (T1%,YE1%)	next n	for n = 0 to j1	    T% = int (n * TSC +X0%)	    T1% = int ((n+1) * TSC +X0%)	   	   	     	    YE% = int (4 * YS - rmp * R(n))            YE1% = int (4 * YS - rmp * R(n+1))	    LINE (T%,YE%) - (T1%,YE1%)	next n			INPUT Q$ 	PRINT" NEW PLOT y or n";:INPUT Q$	IF Q$ = "y" OR Q$ = "Y" GOTO 5000    