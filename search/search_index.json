{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"echoSMs","text":"<p>Making acoustic scattering models available to fisheries and plankton scientists via the world wide web.</p>"},{"location":"#background","title":"Background","text":"<p>This project is an international collaboration that is, in part, a component of a U.S. NOAA-Fisheries active acoustic strategic initiative, AA-SI.</p> <p>Quantitative interpretation of acoustic echograms requires software expertise to develop advanced analytical methods for echo classification using mathematical models that predict acoustic backscatter (e.g., target strength, TS re 1 m\u00b2 [dB]). These models and predictions can be used to inform echo classification by validating empirical measurements and generating training data for machine learning (ML), artificial intelligence (AI), and other advanced analytical methods, such as inverse methods. Application of these models to fish and plankton requires anatomical and morphological data that are easily accessible and available to the models.</p> <p>The goal of this project is to make acoustic scattering models available to fisheries and plankton acoustic scientists via the world wide web. By providing the models in an open-access and open-source software language (e.g, Python, R) and providing morphological and anatomical data in open data formats (e.g., HDF5, relational databases), the proper and appropriate use of these models can extend to the entire fisheries and plankton acoustics\u2019 community.</p>"},{"location":"#contributing-to-echosms","title":"Contributing to echoSMs","text":"<p>We welcome all contributions to echoSMs, be it code, test cases, bug reports, discussion of models, etc. Please use the github facilities for this (i.e., issues, pull requests, and discussions). We are also happy to accept directly code that we can add to echoSMs on your behalf.</p> <p>An objective of echoSMs is to provide scattering models in a form that is easy to access, use, and compare to other models. To help with that, we specify model parameter units, angle conventions, and required model outputs that code contributions should support. We also suggest coding conventions that should be followed.</p>"},{"location":"#scattering-models","title":"Scattering Models","text":"<p>The initial set of acoustic scattering models will be those used in Jech et al. (2015). Acoustic model development will follow 3\u20134 phases:</p> <ol> <li>Exact solutions and canonical shapes (see table below),</li> <li>Approximate analytical models applied to canonical shapes (see table below),</li> <li>Approximate analytical models applied to complex shapes approximating biological targets, such as fish and zooplankton,</li> <li>Numerical models applied to canonical shapes and biological targets (this phase will depend on time and funding).</li> </ol>"},{"location":"#exact-solutions","title":"Exact Solutions","text":"<p>The exact solutions, shapes, and supported boundary conditions will be:</p> Model Shape Description References Modal Series solution (MSS) Sphere Fluid filled 1,2 Fixed rigid 2,3 Pressure release 2 Gas filled 2 Weakly scattering 2 Spherical fluid shell with fluid interior 2 Fixed rigid spherical shell 2 Spherical fluid shell with pressure release interior 2 Spherical fluid shell with gas interior 2 Spherical fluid shell with weakly scattering interior 2 Prolate spheroid modal series solution Prolate spheroid Rigid fixed 2,4,5 Pressure release 2,4,5 Gas filled 2,4,5 Infinite cylinder? 3 Infinite plane? <ol> <li>Anderson, V. C. 1950. Sound scattering from a fluid sphere. JASA. 22(4): 426-431]</li> <li>Jech et al. 2015. Comparisons among ten models of acoustic backscattering used in aquatic ecosystem research. JASA. 138: 3742-3764.</li> <li>Faran, J. J. 1951. Sound scattering by solid cylinders and spheres. JASA. 23(4): 405-418.</li> <li>Skudrzyk. 1971. The Foundations of Acoustics (Springer, NY), pp. 455-465.</li> <li>Furusawa. 1988. Prolate spheroidal models for predicting general trends of fish target strength, J. Acoust. Soc. Jpn. (E) 9, 13\u201314.</li> </ol>"},{"location":"#approximate-analytical-models-and-shapes","title":"Approximate Analytical Models and Shapes","text":"<p>The approximate analytical models,shapes, and supported boundary conditions will be:</p> Model Shape Description References Modal series-based deformed cylinder model Finite cylinder Fixed rigid 1,2,3 Pressure release 1,2,3 Gas filled 1,2,3 Weakly scattering 1,2,3 Prolate spheroid Fixed rigid 1,2,3 Pressure release 1,2,3 Gas filled 1,2,3 Weakly scattering 1,2,3 Kirchhoff approximation (KA) Sphere Fixed rigid 3,4,5 Prolate spheroid Fixed rigid 3,4,5 Finite cylinder Fixed rigid 3,4,5 Kirchhoff ray mode (KRM) Sphere Gas filled 3,6,7,8 Weakly scattering 3,6,7,8 Spherical shell gas filled 3,6,7,8 Weakly scattering 3,6,7,8 Prolate spheroid gas filled 3,6,7,8 Weakly scattering 3,6,7,8 Finite cylinder gas filled 3,6,7,8 Weakly scattering 3,6,7,8 Distorted wave Born approximation (DWBA) Sphere Weakly scattering 3,9,10,11 Prolate spheroid Weakly scattering 3,9,10,11 Finite cylinder Weakly scattering 3,9,10,11 Phase-tracking distorted wave Born approximation (PT-DWBA) Sphere Weakly scattering 3,12 Spherical shell Weakly scattering 3,12 Prolate spheroid Weakly scattering 3,12 Finite cylinder Weakly scattering 3,12 Stochastic distorted wave Born approximation (SDWBA) Sphere Weakly scattering 13,14,15 Prolate spheroid Weakly scattering 13,14,15 Finite cylinder Weakly scattering 13,14,15 <ol> <li>Stanton. 1988. Sound scattering by cylinders of finite length. I. Fluid cylinders. JASA. 83, 55\u201363.</li> <li>Stanton. 1989. Sound scattering by cylinders of finite length. III. Deformed cylinders. JASA. 86: 691-705.</li> <li>Jech et al. 2015. Comparisons among ten models of acoustic backscattering used in aquatic ecosystem research. JASA. 138: 3742-3764.</li> <li>Foote. 1985. Rather-high-frequency sound scattering by swimbladdered fish. JASA. 78: 688-700.</li> <li>Foote and Francis. 2002. Comparing Kirchhoff approximation and boundary-element models for computing gadoid target strengths. JASA. 111: 1644-1654.</li> <li>Clay and Horne. 1994. Acoustic models of fish: The Atlantic cod (Gadus morhua). JASA. 96: 1661-1668.</li> <li>Clay. 1991. Low-resolution acoustic scattering models: Fluid-filled cylinders and fish with swim bladders. JASA. 89: 2168-2179.</li> <li>Clay. 1992. Composite ray-mode approximations for backscattered sound from gas-filled cylinders and swimbladders. JASA. 92: 2173-2180.</li> <li>Chu et al. 1993. Further analysis of target strength measurements of Antarctic krill at 38 and 120 kHz: Comparison with deformed cylinder model and inference of orientation distribution. JASA. 93: 2985-2988.</li> <li>Stanton et al. 1993. Average echoes from randomly oriented random-length finite cylinders: Zooplankton models. JASA. 94: 3463-3472.]</li> <li>Stanton et al. 1998. Sound scattering by several zooplankton groups II: Scattering models. JASA. 103: 236-253.</li> <li>Jones et al. 2009. Use of the distorted wave Born approximation to predict scattering by inhomogeneous objects: Application to squid. JASA. 125: 73-88.</li> <li>Demer and Conti. 2003. Reconciling theoretical versus empirical target strengths of krill: Effects of phase variability on the distorted wave Born approximation. ICES J. Mar. Sci. 60: 429-434.</li> <li>Demer and Conti. 2004. Erratum: Reconciling theoretical versus empirical target strengths of krill; effects of phase variability on the distorted-wave, Born approximation. ICES J. Mar. Sci. 61: 157-158.</li> <li>TBC</li> </ol>"},{"location":"api_reference/","title":"API reference","text":"<p>This is the API reference for the echoSMs package.</p> <p>Each type of model is contained in a separate Python class (with name ending in <code>Model</code>), but with common calling signatures across all model classes, as defined in <code>ScatterModelBase</code>. There are also classes to provide ready access to the benchmark models and reference model definitions. There are also utility functions.</p>"},{"location":"api_reference/#echosms.ScatterModelBase","title":"<code>echosms.ScatterModelBase()</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for a class that provides a scattering model.</p> <p>All scattering models should inherit from this class, have a name that ends with 'Model', and provide initialisation and calculate_ts_single() functions.</p> <p>Initialise.</p> ATTRIBUTE DESCRIPTION <code>long_name</code> <p>The long name of the model.</p> <p> TYPE: <code>str</code> </p> <code>short_name</code> <p>A short version of the model's long name, typically an acronym.</p> <p> TYPE: <code>str</code> </p> <code>analytical_type</code> <p>Whether the model implements an <code>exact</code> or an <code>approximate</code> model.</p> <p> TYPE: <code>str</code> </p> <code>boundary_types</code> <p>The types of boundary conditions that the model provides, e.g., 'fixed rigid', 'pressure release', 'fluid filled'</p> <p> TYPE: <code>list[boundary_type]</code> </p> <code>shapes</code> <p>The target shapes that the model can represent.</p> <p> TYPE: <code>list[str]</code> </p> <code>max_ka</code> <p>An approximate maximum ka value that will result in accurate target strength results. Note that ka is often not the only parameter that determines the accuracy of the model (e.g., aspect ratio and incident angle can also affect the accuracy).</p> <p> TYPE: <code>float</code> </p> <code>no_expand_parameters</code> <p>The model parameters that are not expanded into Pandas DataFrame columns or Xarray DataArray coordinates. They will instead end up as a dict in the DataFrame or DataArray <code>attrs</code> attribute.</p> <p> TYPE: <code>list[str]</code> </p> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>@abc.abstractmethod\ndef __init__(self):\n    \"\"\"Initialise.\n\n    Attributes\n    ----------\n    long_name : str\n        The long name of the model.\n    short_name : str\n        A short version of the model's long name, typically an acronym.\n    analytical_type : str\n        Whether the model implements an ``exact`` or an ``approximate`` model.\n    boundary_types : list[boundary_type]\n        The types of boundary conditions that the model provides, e.g., 'fixed rigid',\n        'pressure release', 'fluid filled'\n    shapes : list[str]\n        The target shapes that the model can represent.\n    max_ka : float\n        An approximate maximum ka value that will result in accurate target strength results.\n        Note that ka is often not the only parameter that determines the accuracy of the\n        model (e.g., aspect ratio and incident angle can also affect the accuracy).\n    no_expand_parameters : list[str]\n        The model parameters that are not expanded into Pandas DataFrame columns or\n        Xarray DataArray coordinates. They will instead end up as a dict in the DataFrame or\n        DataArray `attrs` attribute.\n    \"\"\"\n    self.long_name = ''\n    self.short_name = ''\n    self.analytical_type = ''\n    self.boundary_types = []\n    self.shapes = []\n    self.max_ka = np.nan\n    self.no_expand_parameters = []\n</code></pre>"},{"location":"api_reference/#echosms.ScatterModelBase.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.ScatterModelBase.calculate_ts_single","title":"<code>calculate_ts_single()</code>  <code>abstractmethod</code>","text":"<p>Calculate the TS for one parameter set.</p> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>@abc.abstractmethod\ndef calculate_ts_single(self):\n    \"\"\"Calculate the TS for one parameter set.\"\"\"\n</code></pre>"},{"location":"api_reference/#echosms.ScatterModelBase.validate_parameters","title":"<code>validate_parameters(p)</code>  <code>abstractmethod</code>","text":"<p>Validate the model parameters.</p> PARAMETER DESCRIPTION <code>p</code> <p>The model parameters.</p> <p> TYPE: <code>dict | DataFrame | DataArray</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If any of the model parameters are invalid.</p> <code>KeyError</code> <p>If any required model parameters are not present.</p> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>@abc.abstractmethod\ndef validate_parameters(self, p: dict | pd.DataFrame | xr.DataArray):\n    \"\"\"Validate the model parameters.\n\n    Parameters\n    ----------\n    p :\n        The model parameters.\n\n    Raises\n    ------\n    ValueError\n        If any of the model parameters are invalid.\n    KeyError\n        If any required model parameters are not present.\n    \"\"\"\n</code></pre>"},{"location":"api_reference/#echosms.DCMModel","title":"<code>echosms.DCMModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>Modal series deformed cylinder model (DCM).</p> <p>This class contains methods to calculate acoustic scatter from finite straight cylinders with various boundary conditions.</p> Source code in <code>src/echosms/dcmmodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'deformed cylinder model'\n    self.short_name = 'dcm'\n    self.analytical_type = 'approximate analytical'\n    self.boundary_types = [bt.fixed_rigid, bt.pressure_release, bt.fluid_filled]\n    self.shapes = ['finite cylinder']\n    self.max_ka = 20  # [1]\n</code></pre>"},{"location":"api_reference/#echosms.DCMModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.DCMModel.calculate_ts_single","title":"<code>calculate_ts_single(medium_c, medium_rho, a, b, theta, f, boundary_type, target_c=None, target_rho=None, validate_parameters=True, **kwargs)</code>","text":"<p>Calculate the scatter from a finite cylinder using the modal series deformed cylinder model.</p> PARAMETER DESCRIPTION <code>medium_c</code> <p>Sound speed in the fluid medium surrounding the target [m/s].</p> <p> TYPE: <code>float</code> </p> <code>medium_rho</code> <p>Density of the fluid medium surrounding the target [kg/m\u00b3].</p> <p> TYPE: <code>float</code> </p> <code>a</code> <p>Radius of the cylinderical target [m].</p> <p> TYPE: <code>float</code> </p> <code>b</code> <p>Length of the cylinderical target [m].</p> <p> TYPE: <code>float</code> </p> <code>theta</code> <p>Pitch angle to calculate the scattering as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to calculate the scattering at [Hz].</p> <p> TYPE: <code>float</code> </p> <code>boundary_type</code> <p>The model type. Supported model types are given in the <code>boundary_types</code> class attribute.</p> <p> TYPE: <code>boundary_type</code> </p> <code>target_c</code> <p>Sound speed in the fluid inside the sphere [m/s]. Only required for <code>boundary_type</code> of <code>fluid_filled</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>target_rho</code> <p>Density of the fluid inside the sphere [kg/m\u00b3]. Only required for <code>boundary_type</code> of <code>fluid_filled</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>validate_parameters</code> <p>Whether to validate the model parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) of the target [dB].</p> Notes <p>The class implements the code in Section B.1 of Jech et al. (2015).</p> References <p>Jech, J.M., Horne, J.K., Chu, D., Demer, D.A., Francis, D.T.I., Gorska, N., Jones, B., Lavery, A.C., Stanton, T.K., Macaulay, G.J., Reeder, D.B., Sawada, K., 2015. Comparisons among ten models of acoustic backscattering used in aquatic ecosystem research. Journal of the Acoustical Society of America 138, 3742\u20133764. https://doi.org/10.1121/1.4937607</p> Source code in <code>src/echosms/dcmmodel.py</code> <pre><code>def calculate_ts_single(self, medium_c, medium_rho, a, b, theta, f, boundary_type: bt,\n                        target_c=None, target_rho=None, validate_parameters=True,\n                        **kwargs):\n    \"\"\"\n    Calculate the scatter from a finite cylinder using the modal series deformed cylinder model.\n\n    Parameters\n    ----------\n    medium_c : float\n        Sound speed in the fluid medium surrounding the target [m/s].\n    medium_rho : float\n        Density of the fluid medium surrounding the target [kg/m\u00b3].\n    a : float\n        Radius of the cylinderical target [m].\n    b : float\n        Length of the cylinderical target [m].\n    theta : float\n        Pitch angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n    f : float\n        Frequency to calculate the scattering at [Hz].\n    boundary_type :\n        The model type. Supported model types are given in the `boundary_types` class attribute.\n    target_c : float, optional\n        Sound speed in the fluid inside the sphere [m/s].\n        Only required for `boundary_type` of ``fluid_filled``.\n    target_rho : float, optional\n        Density of the fluid inside the sphere [kg/m\u00b3].\n        Only required for `boundary_type` of ``fluid_filled``.\n    validate_parameters : bool\n        Whether to validate the model parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) of the target [dB].\n\n    Notes\n    -----\n    The class implements the code in Section B.1 of Jech et al. (2015).\n\n    References\n    ----------\n    Jech, J.M., Horne, J.K., Chu, D., Demer, D.A., Francis, D.T.I., Gorska, N., Jones, B.,\n    Lavery, A.C., Stanton, T.K., Macaulay, G.J., Reeder, D.B., Sawada, K., 2015.\n    Comparisons among ten models of acoustic backscattering used in aquatic ecosystem\n    research. Journal of the Acoustical Society of America 138, 3742\u20133764.\n    &lt;https://doi.org/10.1121/1.4937607&gt;\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    if theta == 0.0:\n        return nan\n\n    theta_rad = theta*pi/180.\n    kL = wavenumber(medium_c, f)*b\n    K = wavenumber(medium_c, f) * sin(theta_rad)\n    Ka = K*a\n\n    m = range(30)  # TODO this needs to vary with f\n\n    match boundary_type:\n        case bt.fixed_rigid:\n            series = map(lambda m: (-1)**m * Neumann(m)*(jvp(m, Ka) / h1vp(m, Ka)), m)\n        case bt.pressure_release:\n            series = map(lambda m: (-1)**m * Neumann(m)*(jv(m, Ka) / hankel1(m, Ka)), m)\n        case bt.fluid_filled:\n            g = target_rho/medium_rho\n            h = target_c/medium_c\n            gh = g*h\n            Kda = K/h*a\n\n            def Cm(m):\n                numer = (jvp(m, Kda)*yv(m, Ka)) / (jv(m, Kda)*jvp(m, Ka))\\\n                    - gh*(yvp(m, Ka)/jvp(m, Ka))\n                denom = (jvp(m, Kda)*jv(m, Ka)) / (jv(m, Kda)*jvp(m, Ka)) - gh\n                return numer/denom\n\n            series = map(lambda m: 1j**(2*m) * Neumann(m) / (1 + 1j*Cm(m)), m)\n        case _:\n            raise ValueError(f'The {self.long_name} model does not support '\n                             f'a model type of \"{boundary_type}\".')\n\n    fbs = 1j*b/pi * (sin(kL*cos(theta_rad)) / (kL*cos(theta_rad))) * sum(series)\n    return 20*log10(abs(fbs))  # ts\n</code></pre>"},{"location":"api_reference/#echosms.DCMModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/dcmmodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n    \"\"\"\n    p = as_dict(params)\n    super()._present_and_in(p, ['boundary_type'], self.boundary_types)\n    super()._present_and_positive(p, ['medium_rho', 'medium_c', 'a', 'b', 'f'])\n\n    types = np.unique(np.atleast_1d(p['boundary_type']))\n    for t in types:\n        if t == bt.fluid_filled:\n            super()._present_and_positive(p, ['target_c', 'target_rho'],\n                                          mask=p['boundary_type'] == t)\n</code></pre>"},{"location":"api_reference/#dwba-models","title":"DWBA models","text":"<p>There are several models that use the distorted-wave Born approximation, documented below. There are also some functions to make cylinder and spheroid shapes for use in the DWBA models.</p>"},{"location":"api_reference/#echosms.DWBAModel","title":"<code>echosms.DWBAModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>Distorted-wave Born approximation (DWBA) scattering models.</p> <p>This class calculates acoustic scatter from piecewise cylindical shapes with weakly scattering material contrasts. It can also add a stochastic component to provide the stochastic DWBA (SDWBA) model.</p> Source code in <code>src/echosms/dwbamodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'distorted-wave Born approximation'\n    self.short_name = 'dwba'\n    self.analytical_type = 'approximate'\n    self.boundary_types = [bt.fluid_filled]\n    self.shapes = ['piecewise cylindical']\n    self.max_ka = 20\n    # The distorted wave Born approximation is increasingly inaccurate outside these limits:\n    self.g_range = [0.95, 1.05]\n    self.h_range = [0.95, 1.05]\n    self.no_expand_parameters = ['a', 'rv_pos', 'rv_tan']\n    self.rng = np.random.default_rng()  # for SDWBA\n</code></pre>"},{"location":"api_reference/#echosms.DWBAModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.DWBAModel.calculate_ts_single","title":"<code>calculate_ts_single(medium_c, medium_rho, theta, phi, f, target_c, target_rho, a, rv_pos, rv_tan, phase_sd=0, num_runs=1, validate_parameters=True, **kwargs)</code>","text":"<p>Distorted-wave Born approximation scattering model.</p> <p>Implements the distorted-wave Born approximation and stochastic DWBA model for calculating the acoustic backscatter from weakly scattering bodies.</p> PARAMETER DESCRIPTION <code>medium_c</code> <p>Sound speed in the fluid medium surrounding the target [m/s].</p> <p> TYPE: <code>float</code> </p> <code>medium_rho</code> <p>Density of the fluid medium surrounding the target [kg/m\u00b3].</p> <p> TYPE: <code>float</code> </p> <code>theta</code> <p>Pitch angle to calculate the scattering as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>phi</code> <p>Roll angle to calculate the scattering as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to run the model at [Hz]</p> <p> TYPE: <code>float</code> </p> <code>target_c</code> <p>Sound speed in the fluid inside the target [m/s].</p> <p> TYPE: <code>float</code> </p> <code>target_rho</code> <p>Density of the fluid inside the target [kg/m\u00b3].</p> <p> TYPE: <code>float</code> </p> <code>a</code> <p>The radii of the discs that define the target shape [m].</p> <p> TYPE: <code>iterable</code> </p> <code>rv_pos</code> <p>An interable of vectors of the 3D positions of the centre of each disc that defines the target shape. Each vector should have three values corresponding to the x, y, and z coordinates [m] of the disc centre.</p> <p> TYPE: <code>iterable[ndarray]</code> </p> <code>rv_tan</code> <p>An interable of unit vectors of the tangent to the target body axis at the points given in <code>rv_pos</code>. Each vector should have three values corresponding to the x, y, and z components of the tangent vector.</p> <p> TYPE: <code>iterable[ndarray]</code> </p> <code>phase_sd</code> <p>If non-zero, this model becomes the SDWBA (stochastic DWBA). A random phase is applied to each term in the DWBA integral, obtained from a Gaussian distribution centered on 0 with standard deviation of <code>phase_sd</code> [\u00b0].</p> <p> TYPE: <code>float</code> DEFAULT: <code>0</code> </p> <code>num_runs</code> <p>The number of times to run the SDWBA model. The mean TS (calculated in the linear domain) is returned. Intended to be used in conjunction with <code>phase_sd</code>.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> <code>validate_parameters</code> <p>Whether to validate the model parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) [dB] of the target.</p> Notes <p>This class implements the method presented in Eqn (5) of Stanton et al. (1998). This caters to objects that are discretised into a set of adjacent discs with potentially offset centres.</p> <p>The DWBA model density and sound speed values are often specified as ratios of the medium and target values (g &amp; h). However, to maintain compatibility with other echoSMs models this implementation requires actual densities and sound speeds.</p> <p>The SDWBA component is as per Demer &amp; Conti (2003).</p> References <p>Demer, D. A., &amp; Conti, S. G. (2003). Reconciling theoretical versus empirical target strengths of krill: Effects of phase variability on the distorted-wave Born approximation. ICES Journal of Marine Science, 60, 429-434. https://doi.org/10.1016/S1054-3139(03)00002-X</p> <p>Stanton, T. K., Chu, D., &amp; Wiebe, P. H. (1998). Sound scattering by several zooplankton groups. II. Scattering models. The Journal of the Acoustical Society of America, 103(1), 236-253. https://doi.org/10.1121/1.421110</p> Source code in <code>src/echosms/dwbamodel.py</code> <pre><code>def calculate_ts_single(self, medium_c, medium_rho, theta, phi, f, target_c, target_rho,\n                        a, rv_pos, rv_tan, phase_sd=0, num_runs=1, validate_parameters=True,\n                        **kwargs) -&gt; float:\n    \"\"\"Distorted-wave Born approximation scattering model.\n\n    Implements the distorted-wave Born approximation and stochastic DWBA\n    model for calculating the acoustic backscatter from weakly scattering bodies.\n\n    Parameters\n    ----------\n    medium_c : float\n        Sound speed in the fluid medium surrounding the target [m/s].\n    medium_rho : float\n        Density of the fluid medium surrounding the target [kg/m\u00b3].\n    theta : float\n        Pitch angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n    phi : float\n        Roll angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n    f : float\n        Frequency to run the model at [Hz]\n    target_c : float\n        Sound speed in the fluid inside the target [m/s].\n    target_rho : float\n        Density of the fluid inside the target [kg/m\u00b3].\n    a : iterable\n        The radii of the discs that define the target shape [m].\n    rv_pos : iterable[np.ndarray]\n        An interable of vectors of the 3D positions of the centre of each disc that\n        defines the target shape. Each vector should have three values corresponding to\n        the _x_, _y_, and _z_ coordinates [m] of the disc centre.\n    rv_tan : iterable[np.ndarray]\n        An interable of unit vectors of the tangent to the target body axis at\n        the points given in `rv_pos`. Each vector should have three values corresponding to\n        the _x_, _y_, and _z_ components of the tangent vector.\n    phase_sd : float\n        If non-zero, this model becomes the SDWBA (stochastic DWBA). A random phase is\n        applied to each term in the DWBA integral, obtained from a Gaussian distribution\n        centered on 0 with standard deviation of `phase_sd` [\u00b0].\n    num_runs : int\n        The number of times to run the SDWBA model. The mean TS (calculated in the\n        linear domain) is returned. Intended to be used in conjunction with `phase_sd`.\n    validate_parameters : bool\n        Whether to validate the model parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) [dB] of the target.\n\n    Notes\n    -----\n    This class implements the method presented in Eqn (5) of Stanton et al. (1998). This\n    caters to objects that are discretised into a set of adjacent discs with potentially\n    offset centres.\n\n    The DWBA model density and sound speed values are often specified as ratios of the medium\n    and target values (g &amp; h). However, to maintain compatibility with other echoSMs models\n    this implementation requires actual densities and sound speeds.\n\n    The SDWBA component is as per Demer &amp; Conti (2003).\n\n    References\n    ----------\n    Demer, D. A., &amp; Conti, S. G. (2003). Reconciling theoretical versus empirical target\n    strengths of krill: Effects of phase variability on the distorted-wave Born approximation.\n    ICES Journal of Marine Science, 60, 429-434.\n    &lt;https://doi.org/10.1016/S1054-3139(03)00002-X&gt;\n\n    Stanton, T. K., Chu, D., &amp; Wiebe, P. H. (1998). Sound scattering by several zooplankton\n    groups. II. Scattering models. The Journal of the Acoustical Society of America, 103(1),\n    236-253. &lt;https://doi.org/10.1121/1.421110&gt;\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    do_sdwba = False if phase_sd == 0.0 else True\n\n    # The structure of this code follows closely the formulae in Stanton et al (1998). Where\n    # relevant, the equation numbers from that paper are given.\n\n    k1 = wavenumber(medium_c, f)\n    k2 = wavenumber(target_c, f)\n    kappa_1 = 1.0 / (medium_rho * medium_c**2)  # Eqn (4) for medium\n    kappa_2 = 1.0 / (target_rho * target_c**2)  # Eqn (4) for target\n    gamma_k = (kappa_2 - kappa_1) / kappa_1  # Eqn (2)\n    gamma_rho = (target_rho - medium_rho) / target_rho  # Eqn (3)\n    # Note: the (gamma_k - gamma_rho) term in Eqn (5) can be simplified using g &amp; h to:\n    # 1/gh^2 + 1/g - 2.\n\n    # Calculate the distance between each disc using the disc position vectors. The Euclidean\n    # distance is the L2 norm so use np.norm(). Could also use\n    # scipy.spatial.distance.euclidean(), but that is apparently a lot slower.\n    dist = np.array([np.linalg.norm(r1-r0) for r0, r1 in zip(rv_pos[0:-1], rv_pos[1:])])  # [m]\n\n    # Thickness of each disc based on the distance between discs. The first and last\n    # discs are treated differently.\n    d_rv_pos = np.hstack((dist[0], dist[0:-1]/2 + dist[1:]/2, dist[-1]))  # [m]\n\n    # Calculate direction of incident wave given theta and phi. The echoSMs convention\n    # has the target rotating and the incident vector always being (0,0,1), but for the DWBA\n    # we keep the body stationary and change the incident vector.\n    rot = R.from_euler('ZYX', (0, theta-90, -phi), degrees=True)\n    k_hat_i = rot.apply([0, 0, 1])  # needs to be a unit vector\n    k_i2 = k_hat_i * k2  # incident vector with magnitude equal to wavenumber inside the target\n\n    # This code is a little complex because it does both the DWBA and SDWBA\n    phase_factors = np.ones(len(a))  # for DWBA\n    runs = []\n\n    for run in range(int(num_runs)):  # is only ever 1 run for the DWBA\n        if do_sdwba:\n            phase_factors = np.exp(1j*self.rng.normal(scale=radians(phase_sd), size=len(a)))\n\n        integral = 0.0\n        for a_, r_pos, d_r_pos, r_tan, p in zip(a, rv_pos, d_rv_pos, rv_tan, phase_factors):\n            # The round() is here because sometimes the dot product gets values slightly outside\n            # the [-1, 1] range (due to floating point inaccuracies) and cos will complain.\n            cbeta_tilt = cos(pi/2 - acos(round(k_hat_i @ r_tan, 8)))\n\n            # This is the integral part of Eqn (5) with addition of\n            # Eqn (4) from Demer &amp; Conti (2003) for the SDWBA part\n            integral += (gamma_k-gamma_rho) * exp(2j*(k_i2@r_pos))\\\n                * a_*j1(2*k2*a_*cbeta_tilt) / cbeta_tilt * abs(d_r_pos) * p\n        runs.append(integral)\n\n    return 20*log10(np.mean(abs(k1/4.0*np.array(runs))))\n</code></pre>"},{"location":"api_reference/#echosms.DWBAModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/dwbamodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n    \"\"\"\n    p = as_dict(params)\n    super()._present_and_positive(p, ['medium_rho', 'medium_c', 'target_rho', 'target_c', 'f'])\n\n    g = p['target_rho'] / p['medium_rho']\n    h = p['target_c'] / p['medium_c']\n\n    if (np.any(g &lt; self.g_range[0])) or np.any((g &gt; self.g_range[1])):\n        warnings.warn('Ratio of target and medium densities (g) is outside the DWBA limits.')\n\n    if (np.any(h &lt; self.h_range[0])) or np.any((h &gt; self.h_range[1])):\n        warnings.warn('Ratio of target and medium sound speeds (h) are '\n                      'outside the DWBA limits.')\n\n    if not np.all([isclose(1.0, np.linalg.norm(v)) for v in p['rv_tan']]):\n        raise ValueError('All vectors in rv_tan must be of unit length.')\n</code></pre>"},{"location":"api_reference/#echosms.PTDWBAModel","title":"<code>echosms.PTDWBAModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>Phase-tracking distorted-wave Born approximation scattering model.</p> Source code in <code>src/echosms/ptdwbamodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'phase-tracking distorted-wave Born approximation'\n    self.short_name = 'pt-dwba'\n    self.analytical_type = 'approximate'\n    self.boundary_types = [bt.fluid_filled]\n    self.shapes = ['unrestricted voxel-based']\n    self.max_ka = 20\n    self.no_expand_parameters = ['volume', 'voxel_size', 'rho', 'c']\n</code></pre>"},{"location":"api_reference/#echosms.PTDWBAModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.PTDWBAModel.calculate_ts_single","title":"<code>calculate_ts_single(volume, theta, phi, f, voxel_size, rho, c, validate_parameters=True, **kwargs)</code>","text":"<p>Phase-tracking distorted-wave Born approximation scattering model.</p> <p>Implements the phase-tracking distorted-wave Born approximation model for calculating the acoustic backscatter from weakly scattering bodies.</p> PARAMETER DESCRIPTION <code>volume</code> <p>The object to be modelled as a 3D volume of voxels. Array contents should be 0 for the surrounding medium, then increasing by 1 for each additional material type (i.e., 1, 2, 3, etc). <code>volume</code> should be arranged as per the echoSMs coordinate system, where</p> <ul> <li>axis 0 (rows) is the x-axis</li> <li>axis 1 (columns) is the y-axis</li> <li>axis 2: (slices) is the z-axis</li> </ul> <p>Increasing axes indices correspond to increasing x, y, and z values.</p> <p> TYPE: <code>Numpy ndarray[int]</code> </p> <code>theta</code> <p>Pitch angle to calculate the scattering as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>phi</code> <p>Roll angle to calculate the scattering as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to run the model at [Hz]</p> <p> TYPE: <code>float</code> </p> <code>voxel_size</code> <p>The size of the voxels in <code>volume</code> [m], ordered (x, y, z). This code assumes that the voxels are cubes so y and z are currently irrelevant.</p> <p> TYPE: <code>iterable[float]</code> </p> <code>rho</code> <p>Densities of each material. Must have at least the same number of entries as unique integers in <code>volume</code> [kg/m\u00b3].</p> <p> TYPE: <code>iterable[float]</code> </p> <code>c</code> <p>Sound speed of each material. Must have at least the same number of entries as unique integers in <code>volume</code> [m/s].</p> <p> TYPE: <code>iterable[float]</code> </p> <code>validate_parameters</code> <p>Whether to validate the model parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) [dB] of the target.</p> Notes <p>This class implements the method presented in Jones et. al. (2009). The code is based closely on the Matlab code in Jones (2006).</p> References <p>Jones, B. A. (2006). Acoustic scattering of broadband echolocation signals from prey of Blainville's beaked whales: Modeling and analysis. Master of Science, Massachusetts Institute of Technology. https://doi.org/10.1575/1912/1283</p> <p>Jones, B. A., Lavery, A. C., &amp; Stanton, T. K. (2009). Use of the distorted wave Born approximation to predict scattering by inhomogeneous objects: Application to squid. The Journal of the Acoustical Society of America, 125(1), 73-88. https://doi.org/10.1121/1.3021298</p> Source code in <code>src/echosms/ptdwbamodel.py</code> <pre><code>def calculate_ts_single(self, volume, theta, phi, f, voxel_size, rho, c,\n                        validate_parameters=True, **kwargs):\n    \"\"\"Phase-tracking distorted-wave Born approximation scattering model.\n\n    Implements the phase-tracking distorted-wave Born approximation\n    model for calculating the acoustic backscatter from weakly scattering bodies.\n\n    Parameters\n    ----------\n    volume : Numpy ndarray[int]\n        The object to be modelled as a 3D volume of voxels. Array contents should be 0\n        for the surrounding medium, then increasing by 1 for each additional material\n        type (i.e., 1, 2, 3, etc). `volume` should be arranged as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems), where\n\n        - axis 0 (rows) is the _x_-axis\n        - axis 1 (columns) is the _y_-axis\n        - axis 2: (slices) is the _z_-axis\n\n        Increasing axes indices correspond to increasing _x_, _y_, and _z_ values.\n\n    theta : float\n        Pitch angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n\n    phi : float\n        Roll angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n\n    f : float\n        Frequency to run the model at [Hz]\n\n    voxel_size : iterable[float]\n        The size of the voxels in `volume` [m], ordered (_x_, _y_, _z_).\n        This code assumes that the voxels are cubes so _y_ and _z_ are currently irrelevant.\n\n    rho : iterable[float]\n        Densities of each material. Must have at least the same number of entries as unique\n        integers in `volume` [kg/m\u00b3].\n\n    c : iterable[float]\n        Sound speed of each material. Must have at least the same number of entries as unique\n        integers in `volume` [m/s].\n    validate_parameters : bool\n        Whether to validate the model parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) [dB] of the target.\n\n    Notes\n    -----\n    This class implements the method presented in Jones et. al. (2009). The code is\n    based closely on the Matlab code in Jones (2006).\n\n    References\n    ----------\n    Jones, B. A. (2006). Acoustic scattering of broadband echolocation signals\n    from prey of Blainville's beaked whales: Modeling and analysis. Master of Science,\n    Massachusetts Institute of Technology. &lt;https://doi.org/10.1575/1912/1283&gt;\n\n    Jones, B. A., Lavery, A. C., &amp; Stanton, T. K. (2009). Use of the distorted\n    wave Born approximation to predict scattering by inhomogeneous objects:\n    Application to squid. The Journal of the Acoustical Society of America,\n    125(1), 73-88. &lt;https://doi.org/10.1121/1.3021298&gt;\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    # Make sure things are numpy arrays\n    rho = np.atleast_1d(rho)\n    c = np.atleast_1d(c)\n    voxel_size = np.array(voxel_size)\n\n    # volume of the voxels [m^3]\n    dv = voxel_size.prod()\n\n    # input parameter checks\n    if not len(volume.shape) == 3:\n        raise TypeError('The volume input variable must be 3-dimensional.')\n\n    if not voxel_size.shape[0] == 3:\n        raise TypeError('The voxel_size input variable must contain 3 items.')\n\n    if not np.any(voxel_size &gt; 0):\n        raise ValueError('All voxel_size values must be positive.')\n\n    if f &lt; 0.0:\n        raise ValueError('The f input variable must contain only positive values.')\n\n    if (theta &lt; -0.0) or (theta &gt; 180.0):\n        raise ValueError('The theta (pitch) angle must be between -180.0 and +180.0')\n\n    if (phi &lt; -180.0) or (phi &gt; 180.0):\n        raise ValueError('The phi (roll) angle must be between -180.0 and +180.0')\n\n    if volume.min() != 0:\n        raise ValueError('The volume input variable must contain zeros.')\n\n    categories = np.unique(volume)\n    if not len(categories == (volume.max() + 1)):\n        raise ValueError('The integers in volume must include all values in the series '\n                         '(0, 1, 2, ..., n), where n is the largest integer in volume.')\n\n    if not len(rho) &gt;= len(categories):\n        raise ValueError('The target_rho variable must contain at least as many values as '\n                         'unique integers in the volume variable.')\n\n    if not len(c) &gt;= len(categories):\n        raise ValueError('The target_c variable must contain at least as many values '\n                         'as unique integers in the volume variable.')\n\n    # density and sound speed ratios for all object materials\n    g = rho[1:] / rho[0]\n    h = c[1:] / c[0]\n\n    # Do the pitch and roll rotations\n\n    # Convert echoSMs rotation angles (which are intrinsic) into extrinsic as\n    # that is what ndimage.rotate() below uses.\n    if phi == 0.0:  # short circuit the coordinate transformation if we can\n        pitch = theta-90\n        roll = 0.0\n    else:\n        rot = R.from_euler('ZYX', (0, theta-90, -phi), degrees=True)\n        # for backscatter we don't care about yaw\n        _, pitch, roll = rot.as_euler('zyz', degrees=True)\n\n    v = ndimage.rotate(volume, pitch, axes=(0, 2), order=0)\n    v = ndimage.rotate(v, roll, axes=(1, 2), order=0)\n\n    categories = np.unique(v)  # or just take the max?\n\n    # wavenumbers in the various media\n    k = 2.0*np.pi * f / c\n\n    # DWBA coefficients\n    # amplitudes in media 1,2,...,n\n    Cb = 1.0/(g * h**2) + 1.0/g - 2.0  # gamma_kappa - gamma_rho\n    Ca = k[0]**2 * Cb / (4.0*np.pi)  # summation coefficient\n\n    # Differential phase for each voxel.\n    dph = np.zeros(v.shape)\n    masks = []\n    for i, category in enumerate(categories):\n        masks.append(np.isin(v, category))\n        dph[masks[i]] = k[i] * voxel_size[0]\n    masks.pop(0)  # don't need to keep the category[0] mask\n\n    # cumulative summation of phase along the z-direction\n    phase = dph.cumsum(axis=2) - dph/2.0\n    dA = np.zeros(phase.shape, dtype=np.complex128)\n\n    # differential phases for each voxel\n    for i, m in enumerate(masks):\n        dA[m] = Ca[i] * np.exp(2.0*1j*phase[m]) * dv\n\n    # Convert to TS\n    return 20.0 * np.log10(np.abs(dA.sum()))\n</code></pre>"},{"location":"api_reference/#echosms.PTDWBAModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/ptdwbamodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n    \"\"\"\n    p = as_dict(params)\n</code></pre>"},{"location":"api_reference/#echosms.dwbautils","title":"<code>echosms.dwbautils</code>","text":"<p>Miscellaneous functions for the DWBA models.</p>"},{"location":"api_reference/#echosms.dwbautils.DWBAdata","title":"<code>DWBAdata()</code>","text":"<p>Example datasets for the SDWBA and DWBA models.</p> Source code in <code>src/echosms/dwbautils.py</code> <pre><code>def __init__(self):\n    # Load in the shapes data\n    self.file = Path(__file__).parent/Path('resources')/Path('DWBA_shapes.toml')\n    with open(self.file, 'rb') as f:\n        try:\n            shapes = tomllib.load(f)\n        except tomllib.TOMLDecodeError as e:\n            raise SyntaxError(f'Error while parsing file \"{self.defs_filename.name}\"') from e\n\n    # Put the shapes into a dict of DWBAorganism().\n    self.dwba_models = {}\n    for s in shapes['shape']:\n        mx = max(s['x'])\n        s['x'] = np.array(s['x'])-mx  # put head at x=0\n        # Estimate rv_tan from a spline through (x,y,z).\n        tck, u = splprep([s['x'], s['y'], s['z']])\n        rv_tan = np.vstack(splev(u, tck, der=1))\n        # Make sure rv_tan holds only unit vectors\n        n = np.linalg.norm(np.vstack(rv_tan), axis=0)\n        rv_tan = (rv_tan / n).T\n\n        # Convert the x, y, z lists into a 2D array with one row for each (x,y,z) point\n        rv_pos = np.vstack((np.array(s['x']), np.array(s['y']), np.array(s['z']))).T\n\n        organism = DWBAorganism(rv_pos, np.array(s['a']), np.array(s['g']), np.array(s['h']),\n                                s['name'], s.get('source', ''), s.get('note', ''), rv_tan,\n                                s['aphiaid'], s['length'], s['vernacular'],)\n        self.dwba_models[s['name']] = organism\n</code></pre>"},{"location":"api_reference/#echosms.dwbautils.DWBAdata.as_dict","title":"<code>as_dict()</code>","text":"<p>DWBA model shapes as a dict.</p> RETURNS DESCRIPTION <code>dict</code> <p>All the DWBA model shapes. The dataset name is the dict key and the value is an instance of <code>DWBAorganism</code>.</p> Source code in <code>src/echosms/dwbautils.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"DWBA model shapes as a dict.\n\n    Returns\n    -------\n    :\n        All the DWBA model shapes. The dataset name is the dict key and the value is an\n        instance of `DWBAorganism`.\n\n    \"\"\"\n    return self.dwba_models\n</code></pre>"},{"location":"api_reference/#echosms.dwbautils.DWBAdata.model","title":"<code>model(name)</code>","text":"<p>DWBA model shape with requested name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of a DWBA model shape.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>DWBAorganism</code> <p>An instance of <code>DWBAorganism</code> or None if there is no model with <code>name</code>.</p> Source code in <code>src/echosms/dwbautils.py</code> <pre><code>def model(self, name: str) -&gt; DWBAorganism:\n    \"\"\"DWBA model shape with requested name.\n\n    Parameters\n    ----------\n    name :\n        The name of a DWBA model shape.\n\n    Returns\n    -------\n    :\n        An instance of `DWBAorganism` or None if there is no model with `name`.\n\n    \"\"\"\n    try:\n        return self.dwba_models[name]\n    except KeyError:\n        return None\n</code></pre>"},{"location":"api_reference/#echosms.dwbautils.DWBAdata.names","title":"<code>names()</code>","text":"<p>Available DWBA model names.</p> Source code in <code>src/echosms/dwbautils.py</code> <pre><code>def names(self):\n    \"\"\"Available DWBA model names.\"\"\"\n    return [*self.dwba_models]\n</code></pre>"},{"location":"api_reference/#echosms.dwbautils.DWBAorganism","title":"<code>DWBAorganism(rv_pos, a, g, h, name, source='', note='', rv_tan=None, aphiaid=1, length=0.0, vernacular_name='')</code>  <code>dataclass</code>","text":"<p>DWBA shape and property class to represent an organism.</p> ATTRIBUTE DESCRIPTION <code>rv_pos</code> <p>An iterable of vectors of the 3D positions of the centre of each disc that defines the target shape. Each vector should have three values corresponding to the x, y, and z coordinates [m] of the disc centre, as per the echoSMs coordinate system.</p> <p> TYPE: <code>iterable[ndarray]</code> </p> <code>a</code> <p>The radii [m] of each disc.</p> <p> TYPE: <code>ndarray</code> </p> <code>g</code> <p>The density contrast between medium and organism (organism divied by medium).</p> <p> TYPE: <code>ndarray</code> </p> <code>h</code> <p>The sound speed contrast betwwen medium and organism (organism divied by medium).</p> <p> TYPE: <code>ndarray</code> </p> <code>source</code> <p>A link to the source of the data.</p> <p> TYPE: <code>str</code> </p> <code>note</code> <p>Information about the data.</p> <p> TYPE: <code>str</code> </p> <code>rv_tan</code> <p>An iterable of unit vectors of the tangent to the body axis at the points given by (x, y, z). Each vector has three values corresponding to the x, y, and z components of the tangent vector [m]. If not given, unit vectors pointing along the positive x-axis are used.</p> <p> TYPE: <code>ndarray</code> </p>"},{"location":"api_reference/#echosms.dwbautils.DWBAorganism.plot","title":"<code>plot()</code>","text":"<p>Do a simple plot of the DWBA model data.</p> Source code in <code>src/echosms/dwbautils.py</code> <pre><code>def plot(self):\n    \"\"\"Do a simple plot of the DWBA model data.\"\"\"\n    import matplotlib.pyplot as plt\n    fig, axs = plt.subplots(2, 1, layout='compressed')\n    x = self.rv_pos[:, 0]*1e3\n    outline1 = (-self.rv_pos[:, 1] + self.a)*1e3\n    outline2 = (-self.rv_pos[:, 1] - self.a)*1e3\n    axs[0].plot(x, -self.rv_pos[:, 1]*1e3, '.-', c='C0')\n    axs[0].plot(x, outline1, c='C1')\n    axs[0].plot(x, outline2, c='C1')\n    axs[0].plot([x[0], x[0]], [outline1[0], outline2[0]], c='C1')\n    axs[0].plot([x[-1], x[-1]], [outline1[-1], outline2[-1]], c='C1')\n    axs[0].set_title('Dorsal', loc='left', fontsize=8)\n    axs[0].axis('scaled')\n    axs[0].xaxis.set_inverted(True)\n\n    outline1 = (-self.rv_pos[:, 2] + self.a)*1e3\n    outline2 = (-self.rv_pos[:, 2] - self.a)*1e3\n    axs[1].plot(x, -self.rv_pos[:, 2]*1e3, '.-', c='C0')\n    axs[1].plot(x, outline1, c='C1')\n    axs[1].plot(x, outline2, c='C1')\n    axs[1].plot([x[0], x[0]], [outline1[0], outline2[0]], c='C1')\n    axs[1].plot([x[-1], x[-1]], [outline1[-1], outline2[-1]], c='C1')\n    axs[1].set_title('Lateral', loc='left', fontsize=8)\n    axs[1].axis('scaled')\n    axs[1].xaxis.set_inverted(True)\n\n    plt.suptitle(self.name)\n    plt.show()\n</code></pre>"},{"location":"api_reference/#echosms.dwbautils.create_dwba_cylinder","title":"<code>create_dwba_cylinder(radius, length, spacing=0.0001)</code>","text":"<p>Create shape description variables for the DWBA model for cylinders.</p> <p>The shape descriptions are essentially a set of discs and their orientation.</p> PARAMETER DESCRIPTION <code>radius</code> <p>The radius [m] of the cylinder.</p> <p> TYPE: <code>float</code> </p> <code>length</code> <p>The length [m] of the cylinder.</p> <p> TYPE: <code>float</code> </p> <code>spacing</code> <p>The spacing [m] between successive discs.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0001</code> </p> RETURNS DESCRIPTION <code>rv_pos</code> <p>An iterable of vectors of the 3D positions of the centre of each disc that defines the cylinder. Each vector has three values corresponding to the x, y, and z coordinates [m] of the disc centre.</p> <p> TYPE: <code>iterable[ndarray]</code> </p> <code>rv_tan</code> <p>An iterable of unit vectors of the tangent to the cylinder body axis at the points given in <code>rv_pos</code>. Each vector has three values corresponding to the x, y, and z components of the tangent vector.</p> <p> TYPE: <code>iterable[ndarray]</code> </p> <code>a</code> <p>The radii [m] of the discs that define the spheroid.</p> <p> TYPE: <code>iterable</code> </p> Source code in <code>src/echosms/dwbautils.py</code> <pre><code>def create_dwba_cylinder(radius: float, length: float, spacing: float = 0.0001):\n    \"\"\"Create shape description variables for the DWBA model for cylinders.\n\n    The shape descriptions are essentially a set of discs and their orientation.\n\n    Parameters\n    ----------\n    radius :\n        The radius [m] of the cylinder.\n    length :\n        The length [m] of the cylinder.\n    spacing :\n        The spacing [m] between successive discs.\n\n    Returns\n    -------\n    rv_pos : iterable[np.ndarray]\n        An iterable of vectors of the 3D positions of the centre of each disc that\n        defines the cylinder. Each vector has three values corresponding to\n        the _x_, _y_, and _z_ coordinates [m] of the disc centre.\n    rv_tan : iterable[np.ndarray]\n        An iterable of unit vectors of the tangent to the cylinder body axis at\n        the points given in `rv_pos`. Each vector has three values corresponding to\n        the _x_, _y_, and _z_ components of the tangent vector.\n    a : iterable\n        The radii [m] of the discs that define the spheroid.\n    \"\"\"\n    pos = np.linspace(0, length, int(round(length/spacing)))\n    rv_pos = [np.array([x, 0, 0]) for x in pos]\n    rv_tan = [np.array([1, 0, 0])] * len(pos)\n    a = [radius] * len(pos)\n\n    return rv_pos, rv_tan, a\n</code></pre>"},{"location":"api_reference/#echosms.dwbautils.create_dwba_from_xyza","title":"<code>create_dwba_from_xyza(x, y, z, a, name, g=1.0, h=1.0, source='', note='')</code>","text":"<p>Create a DWBAorganism instance from shape data.</p> <p>Converts a centreline and radius definiton of the DWBA shape into that required by the echoSMs implementation of the DWBA (centreline, tangential, and radii vectors).</p> PARAMETER DESCRIPTION <code>x</code> <p>x-coordinates [m] of the centreline of the DWBA shape as per the echoSMs coordinate system.</p> <p> TYPE: <code>Iterable[float]</code> </p> <code>y</code> <p>y-coordinates [m] of the centreline of the DWBA shape as per the echoSMs coordinate system.</p> <p> TYPE: <code>Iterable[float]</code> </p> <code>z</code> <p>z-coordinates [m] of the centreline of the DWBA shape as per the echoSMs coordinate system.</p> <p> TYPE: <code>Iterable[float]</code> </p> <code>a</code> <p>radius [m] of the DWBA shape at each centreline (x,y,z) position.</p> <p> TYPE: <code>Iterable[float]</code> </p> <code>name</code> <p>A name for the organism.</p> <p> TYPE: <code>str</code> </p> <code>source</code> <p>A link/URL/DOI or description for the source of the data.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>note</code> <p>Notes about the organism or data.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>g</code> <p>A single value of g, the ratio of organism density divided by the medium density. This is applied to all parts of the shape.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>h</code> <p>A single value of h, the ratio of organism sound speed divided by the medium sound speed. This is applied to all parts of the shape.</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> RETURNS DESCRIPTION <code>    An instance of DWBAorganism.</code> Notes <p>Here is an example of how to use this function to read in .sat files from the ZooScatR package and convert them into the format required by the echoSMs DWBA model.</p> <pre><code>import pandas as pd\nfrom echosms import create_dwba_from_xyza\n\nfilepath = 'shape.sat'\n\ns = pd.read_csv(filepath, delimiter=' ', names=['y', 'x', 'a'])\n\n# Adjust the data to match the echoSMs units\ns /= 1000  # convert mm to m\n\n# .sat files don't have a z coordinate but echoSMs requires it\ns['z'] = 0.0\n\n# An example of flipping left to right to match the echoSMS coordinate system\ns['x'] = max(s['x']) - s['x']\n\nshape = create_dwba_from_xyza(s['x'], s['y'], s['z'], s['a'], name=filepath, g=1.05, h=1.05)\n</code></pre> Source code in <code>src/echosms/dwbautils.py</code> <pre><code>def create_dwba_from_xyza(x, y, z, a, name: str, g: float = 1.0, h: float = 1.0,\n                          source: str = '', note: str = ''):\n    \"\"\"Create a DWBAorganism instance from shape data.\n\n    Converts a centreline and radius definiton of the DWBA shape into\n    that required by the echoSMs implementation of the DWBA (centreline, tangential, and\n    radii vectors).\n\n    Parameters\n    ----------\n    x : Iterable[float]\n        x-coordinates [m] of the centreline of the DWBA shape as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems).\n    y : Iterable[float]\n        y-coordinates [m] of the centreline of the DWBA shape as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems).\n    z : Iterable[float]\n        z-coordinates [m] of the centreline of the DWBA shape as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems).\n    a : Iterable[float]\n        radius [m] of the DWBA shape at each centreline (x,y,z) position.\n    name :\n        A name for the organism.\n    source :\n        A link/URL/DOI or description for the source of the data.\n    note :\n        Notes about the organism or data.\n    g :\n        A single value of g, the ratio of organism density divided by the\n        medium density. This is applied to all parts of the shape.\n    h :\n        A single value of h, the ratio of organism sound speed divided by\n        the medium sound speed. This is applied to all parts of the shape.\n\n    Returns\n    -------\n        An instance of DWBAorganism.\n\n    Notes\n    -----\n    Here is an example of how to use this function to read in .sat files\n    from the [ZooScatR](https://github.com/AustralianAntarcticDivision/ZooScatR)\n    package and convert them into the format required\n    by the echoSMs DWBA model.\n\n    ```py\n    import pandas as pd\n    from echosms import create_dwba_from_xyza\n\n    filepath = 'shape.sat'\n\n    s = pd.read_csv(filepath, delimiter=' ', names=['y', 'x', 'a'])\n\n    # Adjust the data to match the echoSMs units\n    s /= 1000  # convert mm to m\n\n    # .sat files don't have a z coordinate but echoSMs requires it\n    s['z'] = 0.0\n\n    # An example of flipping left to right to match the echoSMS coordinate system\n    s['x'] = max(s['x']) - s['x']\n\n    shape = create_dwba_from_xyza(s['x'], s['y'], s['z'], s['a'], name=filepath, g=1.05, h=1.05)\n\n    ```\n    \"\"\"\n    # Estimate rv_tan from a spline through (x,y).\n    tck, u = splprep([x, y, z])\n    rv_tan = np.vstack(splev(u, tck, der=1))\n    # Make sure rv_tan holds only unit vectors\n    n = np.linalg.norm(np.vstack(rv_tan), axis=0)\n    rv_tan = (rv_tan / n).T\n\n    # Convert the x, y, and z into a 2D array and get one row for each (x,y,z) point.\n    rv_pos = np.vstack((x, y, z)).T\n\n    gg = np.full((1, rv_pos.shape[0]), g)\n    hh = np.full((1, rv_pos.shape[0]), h)\n\n    return DWBAorganism(rv_pos, a, gg, hh, name, source, note, rv_tan)\n</code></pre>"},{"location":"api_reference/#echosms.dwbautils.create_dwba_spheroid","title":"<code>create_dwba_spheroid(major_radius, minor_radius, spacing=0.0001)</code>","text":"<p>Create shape description variables for the DWBA model for spheres and prolate spheroids.</p> <p>The shape descriptions are essentially a set of discs and their orientation.</p> Notes <p>Currently only supports prolate spheroids and spheres (set <code>major_radius</code> and <code>minor_radius</code> to the same value to get a sphere).</p> PARAMETER DESCRIPTION <code>major_radius</code> <p>The major radius [m] of the spheroid.</p> <p> TYPE: <code>float</code> </p> <code>minor_radius</code> <p>The minor radius [m] of the spheroid.</p> <p> TYPE: <code>float</code> </p> <code>spacing</code> <p>The spacing [m] between successive discs.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.0001</code> </p> RETURNS DESCRIPTION <code>rv_pos</code> <p>An iterable of vectors of the 3D positions of the centre of each disc that defines the spheroid. Each vector has three values corresponding to the x, y, and z coordinates [m] of the disc centre.</p> <p> TYPE: <code>iterable[ndarray]</code> </p> <code>rv_tan</code> <p>An iterable of unit vectors of the tangent to the target body axis at the points given in <code>rv_pos</code>. Each vector has three values corresponding to the x, y, and z components of the tangent vector.</p> <p> TYPE: <code>iterable[ndarray]</code> </p> <code>a</code> <p>The radii [m] of the discs that define the spheroid.</p> <p> TYPE: <code>iterable</code> </p> Source code in <code>src/echosms/dwbautils.py</code> <pre><code>def create_dwba_spheroid(major_radius: float, minor_radius: float, spacing: float = 0.0001):\n    \"\"\"Create shape description variables for the DWBA model for spheres and prolate spheroids.\n\n    The shape descriptions are essentially a set of discs and their orientation.\n\n    Notes\n    -----\n    Currently only supports prolate spheroids and spheres (set `major_radius` and `minor_radius`\n    to the same value to get a sphere).\n\n    Parameters\n    ----------\n    major_radius :\n        The major radius [m] of the spheroid.\n    minor_radius :\n        The minor radius [m] of the spheroid.\n    spacing :\n        The spacing [m] between successive discs.\n\n    Returns\n    -------\n    rv_pos : iterable[np.ndarray]\n        An iterable of vectors of the 3D positions of the centre of each disc that\n        defines the spheroid. Each vector has three values corresponding to\n        the _x_, _y_, and _z_ coordinates [m] of the disc centre.\n    rv_tan : iterable[np.ndarray]\n        An iterable of unit vectors of the tangent to the target body axis at\n        the points given in `rv_pos`. Each vector has three values corresponding to\n        the _x_, _y_, and _z_ components of the tangent vector.\n    a : iterable\n        The radii [m] of the discs that define the spheroid.\n    \"\"\"\n    v = np.linspace(0, np.pi, int(round(2*major_radius/spacing)))\n    a = minor_radius*np.sin(v)  # radius at points along the spheroid\n    x = major_radius-major_radius*np.cos(v)  # shift so that origin is at one end\n\n    # List of disc position vectors\n    rv_pos = [np.array([i, 0, 0]) for i in x]\n\n    # List of tangent vectors to sphere axis (all the same for spheroids)\n    rv_tan = [np.array([1, 0, 0])] * len(x)\n\n    return rv_pos, rv_tan, a\n</code></pre>"},{"location":"api_reference/#echosms.ESModel","title":"<code>echosms.ESModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>Elastic sphere (ES) scattering model.</p> <p>This class calculates acoustic backscatter from elastic spheres.</p> Source code in <code>src/echosms/esmodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'elastic sphere'\n    self.short_name = 'es'\n    self.analytical_type = 'exact'\n    self.boundary_types = [bt.elastic]\n    self.shapes = ['sphere']\n    self.max_ka = 20  # [1]\n</code></pre>"},{"location":"api_reference/#echosms.ESModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.ESModel.calculate_ts_single","title":"<code>calculate_ts_single(medium_c, medium_rho, a, f, target_longitudinal_c, target_transverse_c, target_rho, validate_parameters=True, **kwargs)</code>","text":"<p>Calculate the backscatter from an elastic sphere for one set of parameters.</p> PARAMETER DESCRIPTION <code>medium_c</code> <p>Sound speed in the fluid medium surrounding the sphere [m/s].</p> <p> TYPE: <code>float</code> </p> <code>medium_rho</code> <p>Density of the fluid medium surrounding the sphere [kg/m\u00b3].</p> <p> TYPE: <code>float</code> </p> <code>a</code> <p>Radius of the sphere [m].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to calculate the scattering at [Hz].</p> <p> TYPE: <code>float</code> </p> <code>target_longitudinal_c</code> <p>Longitudinal sound speed in the material inside the sphere [m/s].</p> <p> TYPE: <code>float</code> </p> <code>target_transverse_c</code> <p>Transverse sound speed in the material inside the sphere [m/s].</p> <p> TYPE: <code>float</code> </p> <code>target_rho</code> <p>Density of the material inside the sphere [kg/m\u00b3].</p> <p> TYPE: <code>float</code> </p> <code>validate_parameters</code> <p>Whether to validate the model parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) of the sphere [dB].</p> Notes <p>The class implements the code in MacLennan (1981).</p> References <p>MacLennan, D. N. (1981). The Theory of Solid Spheres as Sonar Calibration Targets. Scottish Fisheries Research Report Number 22. Department of Agriculture and Fisheries for Scotland. https://archive.org/details/scottish-fisheries-research-reports_1981_22</p> Source code in <code>src/echosms/esmodel.py</code> <pre><code>def calculate_ts_single(self, medium_c, medium_rho, a, f,\n                        target_longitudinal_c, target_transverse_c, target_rho,\n                        validate_parameters=True,\n                        **kwargs) -&gt; float:\n    \"\"\"\n    Calculate the backscatter from an elastic sphere for one set of parameters.\n\n    Parameters\n    ----------\n    medium_c : float\n        Sound speed in the fluid medium surrounding the sphere [m/s].\n    medium_rho : float\n        Density of the fluid medium surrounding the sphere [kg/m\u00b3].\n    a : float\n        Radius of the sphere [m].\n    f : float\n        Frequency to calculate the scattering at [Hz].\n    target_longitudinal_c : float\n        Longitudinal sound speed in the material inside the sphere [m/s].\n    target_transverse_c : float\n        Transverse sound speed in the material inside the sphere [m/s].\n    target_rho : float\n        Density of the material inside the sphere [kg/m\u00b3].\n    validate_parameters : bool\n        Whether to validate the model parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) of the sphere [dB].\n\n    Notes\n    -----\n    The class implements the code in MacLennan (1981).\n\n    References\n    ----------\n    MacLennan, D. N. (1981). The Theory of Solid Spheres as Sonar Calibration Targets.\n    Scottish Fisheries Research Report Number 22. Department of Agriculture and Fisheries\n    for Scotland. &lt;https://archive.org/details/scottish-fisheries-research-reports_1981_22&gt;\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    q = wavenumber(medium_c, f)*a\n    q1 = q*medium_c/target_longitudinal_c\n    q2 = q*medium_c/target_transverse_c\n    alpha = 2. * (target_rho/medium_rho) * (target_transverse_c/medium_c)**2\n    beta = (target_rho/medium_rho) * (target_longitudinal_c/medium_c)**2 - alpha\n\n    # Use n instead of l (ell) because l looks like 1.\n    def S(n):\n        A2 = (n**2 + n-2) * spherical_jn(n, q2) + q2**2 * spherical_jnpp(n, q2)\n        A1 = 2*n*(n+1) * (q1*spherical_jn(n, q1, True) - spherical_jn(n, q1))\n        B2 = A2*q1**2 * (beta*spherical_jn(n, q1) - alpha*spherical_jnpp(n, q1))\\\n            - A1*alpha * (spherical_jn(n, q2) - q2*spherical_jn(n, q2, True))\n        B1 = q * (A2*q1*spherical_jn(n, q1, True) - A1*spherical_jn(n, q2))\n        eta_n = atan(-(B2*spherical_jn(n, q, True) - B1*spherical_jn(n, q))\n                     / (B2*spherical_yn(n, q, True) - B1*spherical_yn(n, q)))\n\n        return (-1)**n * (2*n+1) * sin(eta_n) * exp(1j*eta_n)\n\n    # Estimate the number of terms to use in the summation\n    n_max = round(q+10)\n    tol = 1e-10  # somewhat arbitrary\n    while abs(S(n_max)) &gt; tol:\n        n_max += 10\n\n    if n_max &gt; 200:\n        warn('TS results may be inaccurate because the modal series required a large '\n             f'number ({n_max}) of terms to converge.')\n\n    n = range(n_max)\n\n    f_inf = -2.0/q * sum(map(S, n))\n\n    return 10*log10(a**2 * abs(f_inf)**2 / 4.0)\n</code></pre>"},{"location":"api_reference/#echosms.ESModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/esmodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n    \"\"\"\n    p = as_dict(params)\n    super()._present_and_in(p, ['boundary_type'], self.boundary_types)\n    super()._present_and_positive(p, ['medium_rho', 'medium_c', 'a', 'f',\n                                      'target_longitudinal_c',\n                                      'target_transverse_c', 'target_rho'])\n</code></pre>"},{"location":"api_reference/#echosms.HPModel","title":"<code>echosms.HPModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>High-pass (HP) scattering model.</p> Source code in <code>src/echosms/hpmodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'high pass'\n    self.short_name = 'hp'\n    self.analytical_type = 'approximate'\n    self.boundary_types = [bt.fluid_filled, bt.elastic, bt.fixed_rigid]\n    self.shapes = ['sphere', 'prolate spheroid', 'cylinder', 'bent cylinder']\n    self.max_ka = 20  # [1]\n</code></pre>"},{"location":"api_reference/#echosms.HPModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.HPModel.calculate_ts_single","title":"<code>calculate_ts_single(shape, medium_c, a, f, boundary_type, medium_rho=None, target_c=None, target_rho=None, theta=None, L=None, rho_c=None, irregular=False, validate_parameters=True, **kwargs)</code>","text":"<p>Calculate the backscatter using the high pass model for one set of parameters.</p> PARAMETER DESCRIPTION <code>shape</code> <p>The shape to model. Must be one of the shapes given in the <code>shapes</code> variable.</p> <p> TYPE: <code>str</code> </p> <code>medium_c</code> <p>Sound speed in the fluid medium surrounding the target [m/s].</p> <p> TYPE: <code>float</code> </p> <code>medium_rho</code> <p>Density of the fluid medium surrounding the target [kg/m\u00b3]. Not required when <code>boundary_type</code> is <code>fixed_rigid</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>target_c</code> <p>Longitudinal sound speed in the material inside the target [m/s]. Not required when <code>boundary_type</code> is <code>fixed_rigid</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>target_rho</code> <p>Density of the material inside the target [kg/m\u00b3]. Not required when <code>boundary_type</code> is <code>fixed_rigid</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>a</code> <p>Radius of the sphere, length of semi-minor axis of the prolate spheriod, or cylindrical radius of the straight or bent cylinder [m].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to calculate the scattering at [Hz].</p> <p> TYPE: <code>float</code> </p> <code>boundary_type</code> <p>The boundary type for the model.</p> <p> TYPE: <code>boundary_type</code> </p> <code>theta</code> <p>Pitch angle to calculate the scattering as per the echoSMs coordinate system [\u00b0]. Only required for the straight cylinder shape.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>L</code> <p>Total length of the prolate spheroid and straight cylinder, or arc length of the bent cylinder [m]. Only required for prolate spheroid, cylinder, and bent cylinder shapes.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>rho_c</code> <p>Radius of curvature of the axis of the bent cylinder [m]. Only required for the bent cylinder shape.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>irregular</code> <p>Set to <code>True</code> if the modelled object is not exactly a sphere, prolate spheroid, straight or uniformly beny cylinder.</p> <p> DEFAULT: <code>False</code> </p> <code>validate_parameters</code> <p>Whether to validate the model parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) of the sphere [dB].</p> Notes <p>The class implements the high-pass model in Stanton (1989) for spheres, prolate spheroids, cylinders, and bent cylinders with fluid filled, elastic, and rigid fixed boundary conditions. There are several restrictions on valid input parameters, so a careful reading of Stanton (1989) is recommended.</p> <p>The theta angle convention used in Stanton (1989) is the same as the echoSMs coordinate system convention.</p> <p>Stanton (1989) also provides parameters for gas-filled shapes, but more prior knowledge is required about the gas for useful results (e.g., damping characteristics of the gas and medium) and these have not been implemented here. There are many other models available that accurately model gas-filled shapes such that the lack of the high-pass gas-filled model should not be missed.</p> References <p>Stanton, T. K. (1989). Simple approximate formulas for backscattering of sound by spherical and elongated objects. The Journal of the Acoustical Society of America, 86(4), 1499-1510. https://doi.org/10.1121/1.398711</p> Source code in <code>src/echosms/hpmodel.py</code> <pre><code>def calculate_ts_single(self, shape, medium_c, a, f, boundary_type: bt, medium_rho=None,\n                        target_c=None, target_rho=None,\n                        theta=None,\n                        L=None, rho_c=None,\n                        irregular=False,\n                        validate_parameters=True, **kwargs) -&gt; float:\n    \"\"\"\n    Calculate the backscatter using the high pass model for one set of parameters.\n\n    Parameters\n    ----------\n    shape : str\n        The shape to model. Must be one of the shapes given in the `shapes` variable.\n    medium_c : float\n        Sound speed in the fluid medium surrounding the target [m/s].\n    medium_rho : float\n        Density of the fluid medium surrounding the target [kg/m\u00b3]. Not required when\n        `boundary_type` is `fixed_rigid`.\n    target_c : float\n        Longitudinal sound speed in the material inside the target [m/s]. Not required when\n        `boundary_type` is `fixed_rigid`.\n    target_rho : float\n        Density of the material inside the target [kg/m\u00b3]. Not required when\n        `boundary_type` is `fixed_rigid`.\n    a : float\n        Radius of the sphere, length of semi-minor axis of the prolate spheriod, or cylindrical\n        radius of the straight or bent cylinder [m].\n    f : float\n        Frequency to calculate the scattering at [Hz].\n    boundary_type :\n        The boundary type for the model.\n    theta : float\n        Pitch angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0]. Only required for the straight cylinder shape.\n    L : float\n        Total length of the prolate spheroid and straight cylinder, or arc length of\n        the bent cylinder [m]. Only required for prolate spheroid, cylinder, and bent cylinder\n        shapes.\n    rho_c : float\n        Radius of curvature of the axis of the bent cylinder [m]. Only required for the\n        bent cylinder shape.\n    irregular :\n        Set to `True` if the modelled object is not exactly a sphere, prolate spheroid,\n        straight or uniformly beny cylinder.\n    validate_parameters : bool\n        Whether to validate the model parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) of the sphere [dB].\n\n    Notes\n    -----\n    The class implements the high-pass model in Stanton (1989) for spheres, prolate spheroids,\n    cylinders, and bent cylinders with fluid filled, elastic, and rigid fixed boundary\n    conditions. There are several restrictions on valid input parameters, so a careful\n    reading of Stanton (1989) is recommended.\n\n    The theta angle convention used in Stanton (1989) is the same as the echoSMs\n    [coordinate system convention](https://ices-tools-dev.github.io/echoSMs/\n    conventions/#coordinate-systems).\n\n    Stanton (1989) also provides parameters for gas-filled shapes, but more\n    prior knowledge is required about the gas for useful results (e.g., damping\n    characteristics of the gas and medium) and these have not been implemented here. There\n    are many other models available that accurately model gas-filled shapes such that the\n    lack of the high-pass gas-filled model should not be missed.\n\n    References\n    ----------\n    Stanton, T. K. (1989). Simple approximate formulas for backscattering of sound\n    by spherical and elongated objects. The Journal of the Acoustical Society of\n    America, 86(4), 1499-1510.\n    &lt;https://doi.org/10.1121/1.398711&gt;\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    if boundary_type == bt.fixed_rigid:\n        # just need something large\n        g = 1e20\n        h = 1e20\n    else:\n        g = target_rho/medium_rho\n        h = target_c/medium_c\n\n    k = wavenumber(medium_c, f)\n\n    G = 1.0\n    F = 1.0\n\n    def alpha_pic(g, h):\n        return (1-g*h*h)/(2*g*h*h) + (1-g)/(1+g)\n\n    match shape:\n        case 'sphere':\n            alpha_pis = (1-g*h*h)/(3*g*h*h) + (1-g)/(1+2*g)\n            R = (g*h-1)/(g*h+1)\n            if irregular:\n                match boundary_type:\n                    case bt.fluid_filled:\n                        F = 40 * (k*a)**(-0.4)\n                        G = 1-0.8*exp(-2.5*(k*a-2.25)**2)\n                    case bt.elastic:\n                        F = 15 * (k*a)**(-1.9)\n                    case bt.fixed_rigid:\n                        F = 15 * (k*a)**(-1.9)\n\n            sigma_bs = a*a * (k*a)**4 * alpha_pis**2 * G\\\n                / (1 + 4*(k*a)**4 * alpha_pis**2/(R**2 * F))\n        case 'prolate spheroid':\n            a_pic = alpha_pic(g, h)\n            if irregular:\n                match boundary_type:\n                    case bt.fluid_filled:\n                        F = 2.5 * (k*a)**(1.65)\n                        G = 1-0.8*exp(-2.5*(k*a-2.3)**2)\n                    case bt.elastic:\n                        F = 1.8 * (k*a)**(-0.4)\n                    case bt.fixed_rigid:\n                        F = 1.8 * (k*a)**(-0.4)\n\n            sigma_bs = 1/9 * L*L * (k*a)**4 * a_pic**2 * G\\\n                / (1 + 16/9*(k*a)**4 * a_pic**2/(R**2 * F))\n        case 'cylinder':\n            theta = radians(theta)\n            a_pic = alpha_pic(g, h)\n            s = sin(k*L*cos(theta)) / (k*L*cos(theta))\n            Ka = k*sin(theta)*a\n            if irregular:\n                match boundary_type:\n                    case bt.fluid_filled:\n                        F = 3 * (k*a)**(0.65)\n                        G = 1-0.8*exp(-2.5*(k*a-2.0)**2)\n                    case bt.elastic:\n                        F = 3.5 * (k*a)**(-1.0)\n                    case bt.fixed_rigid:\n                        F = 3.5 * (k*a)**(-1.0)\n\n            sigma_bs = 0.25 * L*L * (Ka)**4 * a_pic**2 * s*s * G\\\n                / (1 + pi*(Ka)**4 * a_pic**2/(R**2 * F))\n        case 'bent cylinder':\n            a_pic = alpha_pic(g, h)\n            H = 1.\n            if irregular:\n                match boundary_type:\n                    case bt.fluid_filled:\n                        F = 3.0 * (k*a)**(0.65)\n                        G = 1-0.8*exp(-2.5*(k*a-2.0)**2)\n                    case bt.elastic:\n                        F = 2.5 * (k*a)**(-1.0)\n                    case bt.fixed_rigid:\n                        F = 2.5 * (k*a)**(-1.0)\n\n            sigma_bs = 0.25 * L*L * (k*a)**4 * a_pic**2 * H*H*G\\\n                / (1 + L*L*(k*a)**4 * a_pic**2 * H*H/(rho_c*a*R**2 * F))\n\n    return 10*log10(sigma_bs)\n</code></pre>"},{"location":"api_reference/#echosms.HPModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/hpmodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n    \"\"\"\n    p = as_dict(params)\n    super()._present_and_positive(p, ['medium_c', 'a', 'f'])\n\n    if not p['shape'].isin(self.shapes).all():\n        raise ValueError('The shape parameter must be one of: ' + ', '.join(self.shapes))\n\n    if not p['boundary_type'].isin(self.boundary_types).all():\n        raise ValueError('The boundary_type parameter must be one of: ' +\n                         ', '.join(self.boundary_types))\n</code></pre>"},{"location":"api_reference/#echosms.KAModel","title":"<code>echosms.KAModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>Kirchhoff approximation (KA) scattering model.</p> <p>This class calculates acoustic scatter from arbitrary surfaces.</p> Source code in <code>src/echosms/kamodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'Kirchhoff approximation'\n    self.short_name = 'ka'\n    self.analytical_type = 'approximate'\n    self.boundary_types = [bt.pressure_release]\n    self.shapes = ['closed surfaces']\n    self.max_ka = 20  # [1]\n    self.no_expand_parameters = ['mesh']\n</code></pre>"},{"location":"api_reference/#echosms.KAModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.KAModel.calculate_ts_single","title":"<code>calculate_ts_single(medium_c, theta, phi, f, mesh, boundary_type, validate_parameters=True, **kwargs)</code>","text":"<p>Calculate the scatter using the ka model for one set of parameters.</p> PARAMETER DESCRIPTION <code>medium_c</code> <p>Sound speed in the fluid medium surrounding the target [m/s].</p> <p> TYPE: <code>float</code> </p> <code>theta</code> <p>Pitch angle to calculate the scattering as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>phi</code> <p>Roll angle to calculate the scattering as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to calculate the scattering at [Hz].</p> <p> TYPE: <code>float</code> </p> <code>mesh</code> <p>The triangular mesh that defines the scattering surface. This parameter must provide attributes with names of:</p> <ul> <li><code>triangles_center</code> (the position of the centre of each triangular face [m]),</li> <li><code>face_normals</code> (the outward-pointing unit normals for each triangular face),</li> <li><code>area_faces</code> (the area of each triangular face [m\u00b2]).</li> </ul> <p>A suitable library for creating and manipulating triangular meshes is trimesh. Trimesh will accept the usual nodes/facets definition of a mesh and calculate the above attributes automatically.</p> <p> TYPE: <code>Any</code> </p> <code>boundary_type</code> <p>The boundary type. Supported types are given in the <code>boundary_types</code> class variable.</p> <p> TYPE: <code>boundary_type</code> </p> <code>validate_parameters</code> <p>Whether to validate the model parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) of the target [dB].</p> Notes <p>The class implements the code in Foote (1985).</p> References <p>Foote, K. G. (1985). Rather-high-frequency sound scattering of swimbladdered fish. The Journal of the Acoustical Society of America, 78(2), 688\u2013700. https://doi.org/10.1121/1.392438</p> Source code in <code>src/echosms/kamodel.py</code> <pre><code>def calculate_ts_single(self, medium_c, theta, phi, f, mesh,\n                        boundary_type: bt, validate_parameters=True, **kwargs) -&gt; float:\n    \"\"\"\n    Calculate the scatter using the ka model for one set of parameters.\n\n    Parameters\n    ----------\n    medium_c : float\n        Sound speed in the fluid medium surrounding the target [m/s].\n    theta : float\n        Pitch angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n    phi : float\n        Roll angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n    f : float\n        Frequency to calculate the scattering at [Hz].\n    mesh : Any\n        The triangular mesh that defines the scattering surface. This parameter must provide\n        attributes with names of:\n\n        - `triangles_center` (the position of the centre of each triangular face [m]),\n        - `face_normals` (the outward-pointing unit normals for each triangular face),\n        - `area_faces` (the area of each triangular face [m\u00b2]).\n\n        A suitable library for creating and manipulating triangular meshes\n        is [trimesh](https://trimesh.org). Trimesh will accept the usual nodes/facets\n        definition of a mesh and calculate the above attributes automatically.\n    boundary_type :\n        The boundary type. Supported types are given in the `boundary_types` class variable.\n    validate_parameters : bool\n        Whether to validate the model parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) of the target [dB].\n\n    Notes\n    -----\n    The class implements the code in Foote (1985).\n\n    References\n    ----------\n    Foote, K. G. (1985). Rather-high-frequency sound scattering of swimbladdered fish.\n    The Journal of the Acoustical Society of America, 78(2), 688\u2013700.\n    &lt;https://doi.org/10.1121/1.392438&gt;\n\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    if boundary_type not in self.boundary_types:\n        raise ValueError(f'The {self.long_name} model does not support '\n                         f'a model type of \"{boundary_type}\".')\n\n    # This model keeps the organism fixed and varies the incident wave vector. So need\n    # to convert the theta and phi echoSMs coordinate sytem Tait-Bryan angles\n    # into an (x,y,z) vector.\n\n    # Acoustic wave incident vector and its' norm\n    rot = R.from_euler('ZYX', (0, theta-90, -phi), degrees=True)\n    k_norm = rot.as_matrix() @ np.array([[0, 0, 1]]).T\n    k = k_norm * wavenumber(medium_c, f)\n\n    r = mesh.triangles_center  # position vector of each surface element\n    dS = mesh.area_faces.reshape((-1, 1))  # [m^2]\n\n    kn_nn = mesh.face_normals @ k_norm\n\n    fbs = 1./wavelength(medium_c, f)\\\n        * np.sum(np.exp(2j*r @ k) * np.heaviside(kn_nn, 0.5) * kn_nn * dS)\n\n    return 10*log10(abs(fbs)**2)  # ts\n</code></pre>"},{"location":"api_reference/#echosms.KAModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/kamodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n    \"\"\"\n    p = as_dict(params)\n    super()._present_and_in(p, ['boundary_type'], self.boundary_types)\n    super()._present_and_positive(p, ['medium_c', 'f'])\n</code></pre>"},{"location":"api_reference/#krm-model-utilities","title":"KRM model &amp; utilities","text":""},{"location":"api_reference/#echosms.KRMModel","title":"<code>echosms.KRMModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>Kirchhoff ray mode (KRM) scattering model.</p> Source code in <code>src/echosms/krmmodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'Kirchhoff ray mode'\n    self.short_name = 'krm'\n    self.analytical_type = 'approximate'\n    self.boundary_types = [bt.fluid_filled]\n    self.shapes = ['closed surfaces']\n    self.max_ka = 20  # [1]\n    self.no_expand_parameters = ['bodies']\n</code></pre>"},{"location":"api_reference/#echosms.KRMModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.KRMModel.calculate_ts_single","title":"<code>calculate_ts_single(medium_c, medium_rho, theta, f, organism, high_ka_medium='body', low_ka_medium='body', validate_parameters=True, **kwargs)</code>","text":"<p>Calculate the scatter using the Kirchhoff ray mode model for one set of parameters.</p> Warning <p>The mode solution (low ka) part of this model has not yet been verified to give correct results.</p> PARAMETER DESCRIPTION <code>medium_c</code> <p>Sound speed in the fluid medium surrounding the target [m/s].</p> <p> TYPE: <code>float</code> </p> <code>medium_rho</code> <p>Density in the fluid medium surrounding the target [kg/m\u00b3]</p> <p> TYPE: <code>float</code> </p> <code>theta</code> <p>Pitch angle to calculate the scattering at, as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to calculate the scattering at [Hz].</p> <p> TYPE: <code>float</code> </p> <code>organism</code> <p>The shapes that make up the model. This is typically a shape for the body and zero or more enclosed shapes that repesent internal parts of the organism.</p> <p> </p> <code>high_ka_medium</code> <p>If set to <code>body</code> the sound speed and density of the organism body is used for the fluid surrounding any inclusions. If set to anything else (e.g., <code>water</code>) the sound speed and density given by <code>medium_c</code> and <code>medium_rho</code> are used. This parameter applies to the Kirchhoff approximation part of the model (i.e., high ka) and corresponds to the use (or not) of the approximation given in Clay &amp; Horne (1994) on the line immediately below Eqn (13): k_b \u2248 k at low contrast.</p> <p> DEFAULT: <code>'body'</code> </p> <code>low_ka_medium</code> <p>If set to <code>body</code> the sound speed and density of the organism body is used for the fluid surrounding any inclusions. If set to anything else (e.g., <code>water</code>) the sound speed and density given by <code>medium_c</code> and <code>medium_rho</code> are used. This parameter applies to the mode solution part of the model (i.e., low ka) and corresponds to the use (or not) of the approximation given in Clay &amp; Horne (1994) on the line immediately below Eqn (13): k_b \u2248 k at low contrast.</p> <p> DEFAULT: <code>'body'</code> </p> <code>validate_parameters</code> <p>Whether to validate the model parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) of the target [dB].</p> Notes <p>The class implements the code in Clay &amp; Horne (1994) and when ka &lt; 0.15 uses Clay (1992).</p> <p>The <code>high_ka_medium</code> and <code>low_ka_medium</code> parameters allow the user to select which medium surrounds the inclusions (e.g., the swimbladder) - the fish body or the water surrounding the fish body. The equations in Clay &amp; Horne (1994) used the body but included a sentence saying that the water could be used at low contrast (between the water and the body). A later paper (Horne &amp; Jech, 1999) used water for low ka (the mode solution) and the body for higher ka (the Kirchhoff approximation). Some open-source KRM model codes always use the water.</p> References <p>Clay, C. S. (1992). Composite ray-mode approximations for backscattered sound from gas-filled cylinders and swimbladders. The Journal of the Acoustical Society of America, 92(4), 2173\u20132180. https://doi.org/10.1121/1.405211</p> <p>Clay, C. S., &amp; Horne, J. K. (1994). Acoustic models of fish: The Atlantic cod (Gadus morhua). The Journal of the Acoustical Society of America, 96(3), 1661\u20131668. https://doi.org/10.1121/1.410245</p> <p>Horne, J. K., &amp; J. M. Jech. (1999). Multi\u2013frequency estimates of fish abundance: constraints of rather high frequencies. ICES Journal of Marine Science, 56 (2), 184\u2013199. https://doi.org/10.1006/jmsc.1998.0432</p> Source code in <code>src/echosms/krmmodel.py</code> <pre><code>def calculate_ts_single(self, medium_c, medium_rho, theta, f, organism,\n                        high_ka_medium='body', low_ka_medium='body',\n                        validate_parameters=True, **kwargs) -&gt; float:\n    \"\"\"\n    Calculate the scatter using the Kirchhoff ray mode model for one set of parameters.\n\n    Warning\n    --------\n    The mode solution (low _ka_) part of this model has not yet been verified to give\n    correct results.\n\n    Parameters\n    ----------\n    medium_c : float\n        Sound speed in the fluid medium surrounding the target [m/s].\n    medium_rho : float\n        Density in the fluid medium surrounding the target [kg/m\u00b3]\n    theta : float\n        Pitch angle to calculate the scattering at, as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n    f : float\n        Frequency to calculate the scattering at [Hz].\n    organism: KRMorganism\n        The shapes that make up the model. This is typically a shape for the body and zero or\n        more enclosed shapes that repesent internal parts of the organism.\n    high_ka_medium:\n        If set to `body` the sound speed and density of the organism body is used for\n        the fluid surrounding any inclusions. If set to anything else (e.g., `water`)\n        the sound speed and density given by `medium_c` and `medium_rho` are used.\n        This parameter applies to the Kirchhoff approximation part of\n        the model (i.e., high _ka_) and corresponds to the use (or not) of the\n        approximation given in Clay &amp; Horne (1994) on the line immediately below Eqn (13):\n        _k_b \u2248 k at low contrast_.\n    low_ka_medium:\n        If set to `body` the sound speed and density of the organism body is used for\n        the fluid surrounding any inclusions. If set to anything else (e.g., `water`)\n        the sound speed and density given by `medium_c` and `medium_rho` are used.\n        This parameter applies to the mode solution part of the model (i.e., low _ka_)\n        and corresponds to the use (or not) of the approximation given in Clay &amp; Horne (1994)\n        on the line immediately below Eqn (13): _k_b \u2248 k at low contrast_.\n    validate_parameters : bool\n        Whether to validate the model parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) of the target [dB].\n\n    Notes\n    -----\n    The class implements the code in Clay &amp; Horne (1994) and when _ka_ &lt; 0.15 uses Clay (1992).\n\n    The `high_ka_medium` and `low_ka_medium` parameters allow the user to select which\n    medium surrounds the inclusions (e.g., the swimbladder) - the fish body or\n    the water surrounding the fish body. The equations in Clay &amp; Horne (1994) used the body\n    but included a sentence saying that the water could be used at low contrast\n    (between the water and the body). A later paper\n    (Horne &amp; Jech, 1999) used water for low _ka_ (the mode solution) and the body for\n    higher _ka_ (the Kirchhoff approximation). Some open-source KRM model codes always\n    use the water.\n\n    References\n    ----------\n    Clay, C. S. (1992). Composite ray-mode approximations for backscattered sound from\n    gas-filled cylinders and swimbladders. The Journal of the Acoustical Society of\n    America, 92(4), 2173\u20132180.\n    &lt;https://doi.org/10.1121/1.405211&gt;\n\n    Clay, C. S., &amp; Horne, J. K. (1994). Acoustic models of fish: The Atlantic cod\n    (_Gadus morhua_). The Journal of the Acoustical Society of America, 96(3), 1661\u20131668.\n    &lt;https://doi.org/10.1121/1.410245&gt;\n\n    Horne, J. K., &amp; J. M. Jech. (1999). Multi\u2013frequency estimates of fish abundance:\n    constraints of rather high frequencies. ICES Journal of Marine Science, 56 (2), 184\u2013199.\n    &lt;https://doi.org/10.1006/jmsc.1998.0432&gt;\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    theta = radians(theta)\n\n    body = organism.body\n\n    k = wavenumber(medium_c, f)\n    k_b = wavenumber(body.c, f)\n\n    # Reflection coefficient between water and body\n    R_wb = (body.rho*body.c - medium_rho*medium_c)\\\n        / (body.rho*body.c + medium_rho*medium_c)\n    TwbTbw = 1-R_wb**2  # Eqn (15)\n\n    sl = []  # scattering lengths for inclusions\n    for incl in organism.inclusions:\n        # Reflection coefficient between body and inclusion\n        # The paper gives R_bc in terms of g &amp; h, but it can also be done in the\n        # same manner as R_wb above.\n        gp = incl.rho / body.rho  # p is 'prime' to fit with paper notation\n        hp = incl.c / body.c\n\n        R_bc = (gp*hp-1) / (gp*hp+1)  # Eqn (9)\n\n        # Equivalent radius of inclusion (as per Part A of paper)\n        a_e = sqrt(incl.volume() / (pi * incl.length()))\n\n        # Choose which modelling approach to use\n        if k*a_e &lt; 0.15:  # Do the mode solution for the inclusion\n            if low_ka_medium != 'body':\n                gp = incl.rho / medium_rho\n                hp = incl.c / medium_c\n            sl.append(self._mode_solution(1/gp, 1/hp, k, a_e, incl.length(), theta))\n        elif incl.boundary == bt.pressure_release:\n            kk = k_b if high_ka_medium == 'body' else k\n            sl.append(self._soft_KA(incl, k, kk, R_bc, TwbTbw, theta))\n        elif incl.boundary == bt.fluid_filled:\n            kk = k_b if high_ka_medium == 'body' else k\n            sl.append(self._fluid_KA(incl, k, kk, R_bc, TwbTbw, theta))\n        else:\n            raise ValueError(f'Unsupported boundary of \"{incl.boundary}\" for KRM inclusion')\n\n    # Do the Kirchhoff-ray approximation for the body. This is always done as a fluid.\n    body_sl = self._fluid_KA(body, k, k_b, R_wb, TwbTbw, theta)\n\n    return 20*log10(abs(body_sl + sum(sl)))\n</code></pre>"},{"location":"api_reference/#echosms.KRMModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/krmmodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n    \"\"\"\n    p = as_dict(params)\n    super()._present_and_positive(p, ['medium_c', 'f'])\n\n    if np.any(np.atleast_1d(p['theta']) &lt; 65) or np.any(np.atleast_1d(p['theta']) &gt; 115):\n        raise KeyError('Incidence angle(s) (theta) are outside 65 to 115\u00b0')\n</code></pre>"},{"location":"api_reference/#echosms.KRMdata","title":"<code>echosms.KRMdata()</code>","text":"<p>Example datasets for the KRM model.</p> Source code in <code>src/echosms/krmdata.py</code> <pre><code>def __init__(self):\n    # Load in the NOAA KRM shapes data\n    self.file = Path(__file__).parent/Path('resources')/Path('KRM_shapes.toml')\n    with open(self.file, 'rb') as f:\n        try:\n            shapes = tomllib.load(f)\n        except tomllib.TOMLDecodeError as e:\n            raise SyntaxError(f'Error while parsing file \"{self.defs_filename.name}\"') from e\n\n    # Put the shapes into a dict of KRMorganism(). Use some default values for sound speed and\n    # density\n    self.krm_models = {}\n    for s in shapes['shape']:\n        # These KRM data have the head pointing in the -ve x direction,\n        # opposite to the echoSMs coordinate convetion, so fix the\n        # x-coordinates here when ingesting the data. And set the posterior end\n        # of the organism to have x=0\n        m = max(s['x_b'])\n        body = KRMshape(bt.fluid_filled, -np.array(s['x_b']), np.array(s['w_b']),\n                        np.array(s['z_bU']), np.array(s['z_bL']),\n                        s['body_c'], s['body_rho'])\n        swimbladder = KRMshape(bt.pressure_release, -np.array(s['x_sb']), np.array(s['w_sb']),\n                               np.array(s['z_sbU']), np.array(s['z_sbL']),\n                               s['swimbladder_c'], s['swimbladder_rho'])\n        self.krm_models[s['name']] = KRMorganism(s['name'], s['source'],\n                                                 body, [swimbladder],\n                                                 s['aphiaid'], s['length'],\n                                                 s['vernacular'])\n</code></pre>"},{"location":"api_reference/#echosms.KRMdata.as_dict","title":"<code>as_dict()</code>","text":"<p>KRM model shapes as a dict.</p> RETURNS DESCRIPTION <code>dict</code> <p>All the KRM model shapes. The dataset name is the dict key and the value is an instance of <code>KRMorganism</code>.</p> Source code in <code>src/echosms/krmdata.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"KRM model shapes as a dict.\n\n    Returns\n    -------\n    :\n        All the KRM model shapes. The dataset name is the dict key and the value is an instance\n        of `KRMorganism`.\n\n    \"\"\"\n    return self.krm_models\n</code></pre>"},{"location":"api_reference/#echosms.KRMdata.model","title":"<code>model(name)</code>","text":"<p>KRM model shape with requested name.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of a KRM model shape.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>KRMorganism</code> <p>An instance of <code>KRMorganism</code> or None if there is no model with <code>name</code>.</p> Source code in <code>src/echosms/krmdata.py</code> <pre><code>def model(self, name: str) -&gt; KRMorganism:\n    \"\"\"KRM model shape with requested name.\n\n    Parameters\n    ----------\n    name :\n        The name of a KRM model shape.\n\n    Returns\n    -------\n    :\n        An instance of `KRMorganism` or None if there is no model with `name`.\n\n    \"\"\"\n    try:\n        return self.krm_models[name]\n    except KeyError:\n        return None\n</code></pre>"},{"location":"api_reference/#echosms.KRMdata.names","title":"<code>names()</code>","text":"<p>Available KRM model names.</p> Source code in <code>src/echosms/krmdata.py</code> <pre><code>def names(self):\n    \"\"\"Available KRM model names.\"\"\"\n    return [*self.krm_models]\n</code></pre>"},{"location":"api_reference/#echosms.KRMdata.ts","title":"<code>ts(name)</code>  <code>staticmethod</code>","text":"<p>KRM model TS from model <code>name</code>.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of a KRM model shape.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>ndarray</code> <p>The TS (re 1 m\u00b2) for some default model parameters [dB] or None if no TS data are available.</p> Source code in <code>src/echosms/krmdata.py</code> <pre><code>@staticmethod\ndef ts(name: str) -&gt; np.ndarray:\n    \"\"\"KRM model TS from model `name`.\n\n    Parameters\n    ----------\n    name :\n        The name of a KRM model shape.\n\n    Returns\n    -------\n    :\n        The TS (re 1 m\u00b2) for some default model parameters [dB] or None if no TS data\n        are available.\n\n    \"\"\"\n    # Sometimes there will be TS results for the model (available for testing of the\n    # model), so load them in if present.\n    tsfile = Path(__file__).parent/Path('resources')/Path('NOAA_KRM_ts_' + name + '.csv')\n\n    if tsfile.exists():\n        return pd.read_csv(tsfile)\n\n    return None\n</code></pre>"},{"location":"api_reference/#echosms.KRMorganism","title":"<code>echosms.KRMorganism(name, source, body, inclusions, aphiaid=1, length=0.0, vernacular_name='')</code>  <code>dataclass</code>","text":"<p>KRM body and inclusion shape(s).</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>A name for the organism.</p> <p> TYPE: <code>str</code> </p> <code>source</code> <p>A link to or description of the source of the organism data.</p> <p> TYPE: <code>str</code> </p> <code>body</code> <p>The shape that represents the organism's body.</p> <p> TYPE: <code>KRMshape</code> </p> <code>inclusions</code> <p>The shapes that are internal to the organism (e.g., swimbladder, backbone, etc)</p> <p> TYPE: <code>List[KRMshape]</code> </p> <code>aphiaid</code> <p>The aphiaID of the organism</p> <p> TYPE: <code>int</code> </p> <code>length</code> <p>The length of the organism (m)</p> <p> TYPE: <code>float</code> </p> <code>vernacular_name</code> <p>A vernacular name of the organism</p> <p> TYPE: <code>str</code> </p>"},{"location":"api_reference/#echosms.KRMorganism.plot","title":"<code>plot()</code>","text":"<p>Plot of organism shape.</p> Source code in <code>src/echosms/krmdata.py</code> <pre><code>def plot(self):\n    \"\"\"Plot of organism shape.\"\"\"\n    import matplotlib.pyplot as plt\n\n    plt.plot(self.body.x*1e3, self.body.z_U*1e3, self.body.x*1e3, self.body.z_L*1e3, c='black')\n    for i in [0, -1]:  # close the ends of the shape\n        plt.plot([self.body.x[i]*1e3]*2, [self.body.z_U[i]*1e3, self.body.z_L[i]*1e3],\n                 c='black')\n\n    for s in self.inclusions:\n        c = 'C0' if s.boundary == bt.fluid_filled else 'C1'\n        plt.plot(s.x*1e3, s.z_U*1e3, s.x*1e3, s.z_L*1e3, c=c)\n        for i in [0, -1]:  # close the ends of the shape\n            plt.plot([s.x[i]*1e3]*2, [s.z_U[i]*1e3, s.z_L[i]*1e3], c=c)\n\n    plt.gca().set_aspect('equal')\n    plt.gca().xaxis.set_inverted(True)\n    plt.title(self.name)\n    plt.show()\n</code></pre>"},{"location":"api_reference/#echosms.KRMshape","title":"<code>echosms.KRMshape(boundary, x, w, z_U, z_L, c, rho)</code>  <code>dataclass</code>","text":"<p>KRM shape and property class.</p> ATTRIBUTE DESCRIPTION <code>boundary</code> <p>The shape bounday condition - either <code>pressure_release</code> or <code>fluid_filled</code>.</p> <p> TYPE: <code>boundary_type</code> </p> <code>x</code> <p>The x-axis coordinates [m].</p> <p> TYPE: <code>ndarray</code> </p> <code>w</code> <p>Width of the shape [m].</p> <p> TYPE: <code>ndarray</code> </p> <code>z_U</code> <p>Distance from the axis to the upper surface of the shape [m].</p> <p> TYPE: <code>ndarray</code> </p> <code>z_L</code> <p>Distance from the axis to the lower surface of the shape [m].</p> <p> TYPE: <code>ndarray</code> </p> <code>c</code> <p>Sound speed in the shape [m/s].</p> <p> TYPE: <code>float</code> </p> <code>rho</code> <p>Density of the shape material [kg/m\u00b3].</p> <p> TYPE: <code>float</code> </p>"},{"location":"api_reference/#echosms.KRMshape.length","title":"<code>length()</code>","text":"<p>Length of the shape.</p> RETURNS DESCRIPTION <code>float</code> <p>The length of the shape [m].</p> Source code in <code>src/echosms/krmdata.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"Length of the shape.\n\n    Returns\n    -------\n    :\n        The length of the shape [m].\n    \"\"\"\n    return self.x[-1] - self.x[0]\n</code></pre>"},{"location":"api_reference/#echosms.KRMshape.volume","title":"<code>volume()</code>","text":"<p>Volume of the shape.</p> RETURNS DESCRIPTION <code>float</code> <p>The volume of the shape [m\u00b3].</p> Source code in <code>src/echosms/krmdata.py</code> <pre><code>def volume(self) -&gt; float:\n    \"\"\"Volume of the shape.\n\n    Returns\n    -------\n    :\n        The volume of the shape [m\u00b3].\n    \"\"\"\n    thickness = np.diff(self.x)\n    thickness = np.append(thickness, thickness[1])\n    return np.sum(np.pi * (self.z_U - self.z_L) * self.w * thickness)\n</code></pre>"},{"location":"api_reference/#echosms.MSSModel","title":"<code>echosms.MSSModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>Modal series solution (MSS) scattering model.</p> <p>This class calculates acoustic scatter from spheres and shells with various boundary conditions, as listed in the <code>boundary_types</code> class attribute.</p> Source code in <code>src/echosms/mssmodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'modal series solution'\n    self.short_name = 'mss'\n    self.analytical_type = 'exact'\n    self.boundary_types = [bt.fixed_rigid, bt.pressure_release, bt.fluid_filled,\n                           bt.fluid_shell_fluid_interior,\n                           bt.fluid_shell_pressure_release_interior]\n    self.shapes = ['sphere']\n    self.max_ka = 20  # [1]\n</code></pre>"},{"location":"api_reference/#echosms.MSSModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.MSSModel.calculate_ts_single","title":"<code>calculate_ts_single(medium_c, medium_rho, a, f, boundary_type, target_c=None, target_rho=None, shell_c=None, shell_rho=None, shell_thickness=None, validate_parameters=True, **kwargs)</code>","text":"<p>Calculate the scatter using the mss model for one set of parameters.</p> PARAMETER DESCRIPTION <code>medium_c</code> <p>Sound speed in the fluid medium surrounding the target [m/s].</p> <p> TYPE: <code>float</code> </p> <code>medium_rho</code> <p>Density of the fluid medium surrounding the target [kg/m\u00b3].</p> <p> TYPE: <code>float</code> </p> <code>a</code> <p>Radius of the spherical target [m].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to calculate the scattering at [Hz].</p> <p> TYPE: <code>float</code> </p> <code>boundary_type</code> <p>The boundary type. Supported types are given in the <code>boundary_types</code> class variable.</p> <p> TYPE: <code>boundary_type</code> </p> <code>target_c</code> <p>Sound speed in the fluid inside the sphere [m/s]. Only required for <code>boundary_type</code> of <code>fluid_filled</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>target_rho</code> <p>Density of the fluid inside the sphere [kg/m\u00b3]. Only required for <code>boundary_type</code> of <code>fluid_filled</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>shell_c</code> <p>Sound speed in the spherical shell [m/s]. Only required for <code>boundary_type</code>s that include a fluid shell.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>shell_rho</code> <p>Density in the spherical shell [kg/m\u00b3]. Only required for <code>boundary_type</code>s that include a fluid shell.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>shell_thickness</code> <p>Thickness of the spherical shell [m]. This value is subtracted from <code>a</code> to give the radius of the interior sphere. Only required for <code>boundary_type</code>s that include a fluid shell.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>validate_parameters</code> <p>Whether to validate the model parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) of the target [dB].</p> Notes <p>The class implements the code in Section A.1 of Jech et al. (2015).</p> References <p>Jech, J.M., Horne, J.K., Chu, D., Demer, D.A., Francis, D.T.I., Gorska, N., Jones, B., Lavery, A.C., Stanton, T.K., Macaulay, G.J., Reeder, D.B., Sawada, K., 2015. Comparisons among ten models of acoustic backscattering used in aquatic ecosystem research. Journal of the Acoustical Society of America 138, 3742\u20133764. https://doi.org/10.1121/1.4937607</p> Source code in <code>src/echosms/mssmodel.py</code> <pre><code>def calculate_ts_single(self, medium_c, medium_rho, a, f, boundary_type: bt,\n                        target_c=None, target_rho=None,\n                        shell_c=None, shell_rho=None, shell_thickness=None,\n                        validate_parameters=True,\n                        **kwargs) -&gt; float:\n    \"\"\"\n    Calculate the scatter using the mss model for one set of parameters.\n\n    Parameters\n    ----------\n    medium_c : float\n        Sound speed in the fluid medium surrounding the target [m/s].\n    medium_rho : float\n        Density of the fluid medium surrounding the target [kg/m\u00b3].\n    a : float\n        Radius of the spherical target [m].\n    f : float\n        Frequency to calculate the scattering at [Hz].\n    boundary_type :\n        The boundary type. Supported types are given in the `boundary_types` class variable.\n    target_c : float, optional\n        Sound speed in the fluid inside the sphere [m/s].\n        Only required for `boundary_type` of ``fluid_filled``.\n    target_rho : float, optional\n        Density of the fluid inside the sphere [kg/m\u00b3].\n        Only required for `boundary_type` of ``fluid_filled``.\n    shell_c : float, optional\n        Sound speed in the spherical shell [m/s].\n        Only required for `boundary_type`s that include a fluid shell.\n    shell_rho : float, optional\n        Density in the spherical shell [kg/m\u00b3].\n        Only required for `boundary_type`s that include a fluid shell.\n    shell_thickness : float, optional\n        Thickness of the spherical shell [m]. This value is subtracted from ``a`` to give\n        the radius of the interior sphere.\n        Only required for `boundary_type`s that include a fluid shell.\n    validate_parameters : bool\n        Whether to validate the model parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) of the target [dB].\n\n    Notes\n    -----\n    The class implements the code in Section A.1 of Jech et al. (2015).\n\n    References\n    ----------\n    Jech, J.M., Horne, J.K., Chu, D., Demer, D.A., Francis, D.T.I., Gorska, N.,\n    Jones, B., Lavery, A.C., Stanton, T.K., Macaulay, G.J., Reeder, D.B., Sawada, K., 2015.\n    Comparisons among ten models of acoustic backscattering used in aquatic ecosystem\n    research. Journal of the Acoustical Society of America 138, 3742\u20133764.\n    &lt;https://doi.org/10.1121/1.4937607&gt;\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    k0 = wavenumber(medium_c, f)\n    ka = k0*a\n    n = np.arange(0, round(ka+20))\n\n    match boundary_type:\n        case bt.fixed_rigid:\n            A = list(map(lambda x: -spherical_jn(x, ka, True) / h1(x, ka, True), n))\n        case bt.pressure_release:\n            A = list(map(lambda x: -spherical_jn(x, ka) / h1(x, ka), n))\n        case bt.fluid_filled:\n            k1a = wavenumber(target_c, f)*a\n            gh = target_rho/medium_rho * target_c/medium_c\n\n            def Cn_fr(n):\n                return\\\n                    ((spherical_jn(n, k1a, True)*spherical_yn(n, ka))\n                        / (spherical_jn(n, k1a)*spherical_jn(n, ka, True))\n                        - gh*(spherical_yn(n, ka, True)/spherical_jn(n, ka, True)))\\\n                    / ((spherical_jn(n, k1a, True)*spherical_jn(n, ka))\n                       / (spherical_jn(n, k1a)*spherical_jn(n, ka, True))-gh)\n\n            A = -1/(1 + 1j*np.asarray(list(map(Cn_fr, n)), dtype=complex))\n        case bt.fluid_shell_fluid_interior:\n            b = a - shell_thickness\n\n            g21 = shell_rho / medium_rho\n            h21 = shell_c / medium_c\n            g32 = target_rho / shell_rho\n            h32 = target_c / shell_c\n\n            k1a = wavenumber(medium_c, f) * a\n            k2 = wavenumber(shell_c, f)\n            k3b = wavenumber(target_c, f) * b\n\n            def Cn_fsfi(n):\n                (b1, b2, a11, a21, a12, a22, a32, a13, a23, a33) =\\\n                    MSSModel.__eqn9(n, k1a, g21, h21, k2*a, k2*b, k3b, h32, g32)\n                return (b1*a22*a33 + a13*b2*a32 - a12*b2*a33 - b1*a23*a32)\\\n                    / (a11*a22*a33 + a13*a21*a32 - a12*a21*a33 - a11*a23*a32)\n\n            A = list(map(Cn_fsfi, n))\n        case bt.fluid_shell_pressure_release_interior:\n            b = a - shell_thickness\n\n            g21 = shell_rho / medium_rho\n            h21 = shell_c / medium_c\n\n            k1a = wavenumber(medium_c, f) * a\n            k2 = wavenumber(shell_c, f)\n            ksa = k2 * a  # ksa is used in the paper, but isn't that the same as k2a?\n\n            def Cn_fspri(n):\n                (b1, b2, d1, d2, a11, a21) = MSSModel.__eqn10(n, k1a, g21, h21, ksa, k2*a, k2*b)\n                return (b1*d2-d1*b2) / (a11*d2-d1*a21)\n\n            A = list(map(Cn_fspri, n))\n        case _:\n            raise ValueError(f'The {self.long_name} model does not support '\n                             f'a model type of \"{boundary_type}\".')\n\n    fbs = -1j/k0 * np.sum((-1)**n * (2*n+1) * A)\n    return 20*log10(abs(fbs))  # ts\n</code></pre>"},{"location":"api_reference/#echosms.MSSModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/mssmodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n\n    \"\"\"\n    p = as_dict(params)\n    super()._present_and_in(p, ['boundary_type'], self.boundary_types)\n    super()._present_and_positive(p, ['medium_rho', 'a', 'f'])\n\n    types = np.unique(np.atleast_1d(p['boundary_type']))\n    for t in types:\n        mask = p['boundary_type'] == t\n        match t:\n            case bt.fluid_filled:\n                super()._present_and_positive(p, ['target_c', 'target_rho'], mask=mask)\n            case bt.fluid_shell_fluid_interior:\n                super()._present_and_positive(p, ['target_c', 'target_rho', 'shell_c',\n                                                  'shell_rho', 'shell_thickness'], mask=mask)\n            case bt.fluid_shell_pressure_release_interior:\n                super()._present_and_positive(p, ['shell_c', 'shell_rho', 'shell_thickness'],\n                                              mask=mask)\n</code></pre>"},{"location":"api_reference/#echosms.PSMSModel","title":"<code>echosms.PSMSModel()</code>","text":"<p>               Bases: <code>ScatterModelBase</code></p> <p>Prolate spheroidal modal series (PSMS) scattering model.</p> Note <p>The fluid filled boundary type implementation is under development and is of limited use at the moment.</p> Source code in <code>src/echosms/psmsmodel.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.long_name = 'prolate spheroidal modal series'\n    self.short_name = 'psms'\n    self.analytical_type = 'exact'\n    self.boundary_types = [bt.fixed_rigid, bt.pressure_release, bt.fluid_filled]\n    self.shapes = ['prolate spheroid']\n    self.max_ka = 10  # [1]\n</code></pre>"},{"location":"api_reference/#echosms.PSMSModel.calculate_ts","title":"<code>calculate_ts(data, expand=False, inplace=False, multiprocess=False, progress=False)</code>","text":"<p>Calculate the target strength (TS) for many parameters.</p> PARAMETER DESCRIPTION <code>data</code> <p>Requirements for the different input data types are:</p> <ul> <li>DataFrame: column names must match the function parameter names in   calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.</li> <li>DataArray: dimension names must match the function parameter names in   calculate_ts_single(). TS values will be calculated for all combinations of the   coordinate variables.</li> <li>dict: keys must match the function parameters in calculate_ts_single().   TS values will be calculated for all combinations of the dict values.</li> </ul> <p> TYPE: <code>Pandas DataFrame, Xarray DataArray or dict</code> </p> <code>multiprocess</code> <p>Split the ts calculation across CPU cores. Multiprocessing is currently provided by mapply. For more sophisticated uses it may be preferred to use a multiprocessing package of your choice directly on the <code>calculate_ts_single()</code> method. See the code in this method (<code>calculate_ts()</code>) for an example.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>expand</code> <p>Only applicable if <code>data</code> is a dict. If <code>True</code>, will use <code>as_dataframe()</code> to expand the dict into a DataFrame with one column per dict key and return that, adding a column named <code>ts</code> for the results.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>inplace</code> <p>Only applicable if <code>data</code> is a DataFrame. If <code>True</code>, the results will be added to the input DataFrame in a column named <code>ts</code>. If a <code>ts</code> column already exists, it is overwritten.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>progress</code> <p>If <code>True</code>, will produce a progress bar while running models</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None, list[float], Series, or DataFrame</code> <p>The return type and value are determined by the type of the input variable (<code>data</code>) and the <code>expand</code> and <code>inplace</code> parameters:</p> <ul> <li>dict input and <code>expand=False</code> returns a list of floats.</li> <li>dict input and <code>expand=True</code> returns a DataFrame.</li> <li>DataFrame input and <code>inplace=False</code> returns a Series.</li> <li>DataFrame input and <code>inplace=True</code> modifies <code>data</code> and returns <code>None</code>.</li> <li>DataArray input always modifies <code>data</code> and returns <code>None</code>.</li> </ul> Source code in <code>src/echosms/scattermodelbase.py</code> <pre><code>def calculate_ts(self, data, expand=False, inplace=False, multiprocess=False, progress=False):\n    \"\"\"Calculate the target strength (TS) for many parameters.\n\n    Parameters\n    ----------\n    data : Pandas DataFrame, Xarray DataArray or dict\n        Requirements for the different input data types are:\n\n        - **DataFrame**: column names must match the function parameter names in\n          calculate_ts_single(). One TS value will be calculated for each row in the DataFrame.\n        - **DataArray**: dimension names must match the function parameter names in\n          calculate_ts_single(). TS values will be calculated for all combinations of the\n          coordinate variables.\n        - **dict**: keys must match the function parameters in calculate_ts_single().\n          TS values will be calculated for all combinations of the dict values.\n\n    multiprocess : bool\n        Split the ts calculation across CPU cores. Multiprocessing is currently provided by\n        [mapply](https://github.com/ddelange/mapply). For more\n        sophisticated uses it may be preferred to use a multiprocessing package of your choice\n        directly on the `calculate_ts_single()` method. See the code in this method\n        (`calculate_ts()`) for an example.\n\n    expand : bool\n        Only applicable if `data` is a dict. If `True`, will use\n        [`as_dataframe()`][echosms.utils.as_dataframe]\n        to expand the dict into a DataFrame with one column per dict key\n        and return that, adding a column named `ts` for the results.\n\n    inplace : bool\n        Only applicable if `data` is a DataFrame. If `True`, the results\n        will be added to the input DataFrame in a column named `ts`. If a `ts` column\n        already exists, it is overwritten.\n\n    progress : bool\n        If `True`, will produce a progress bar while running models\n\n    Returns\n    -------\n    : None, list[float], Series, or DataFrame\n        The return type and value are determined by the type of the input variable (`data`) and\n        the `expand` and `inplace` parameters:\n\n        - dict input and `expand=False` returns a list of floats.\n        - dict input and `expand=True` returns a DataFrame.\n        - DataFrame input and `inplace=False` returns a Series.\n        - DataFrame input and `inplace=True` modifies `data` and returns `None`.\n        - DataArray input always modifies `data` and returns `None`.\n\n    \"\"\"\n    match data:\n        case dict():\n            data_df = as_dataframe(data, self.no_expand_parameters)\n        case pd.DataFrame():\n            data_df = data\n        case xr.DataArray():\n            data_df = data.to_dataframe().reset_index()\n            data_df.attrs = data.attrs\n        case _:\n            raise ValueError(f'Data type of {type(data)} is not supported'\n                             ' (only dictionaries, Pandas DataFrames and'\n                             ' Xarray DataArrays are).')\n\n    self.validate_parameters(data_df)\n\n    # Get the non-expandable model parameters\n    p = data_df.attrs['parameters'] if 'parameters' in data_df.attrs else {}\n\n    # Note: the args argument in the apply call below requires a tuple. data_df.attrs is a\n    # dict and the default behaviour is to make a tuple using the dict keys. The trailing comma\n    # and parenthesis instead causes the tuple to have one entry of the dict.\n\n    if multiprocess:\n        from mapply.mapply import mapply\n        ts = mapply(data_df, self.__ts_helper, args=(p,), axis=1, progressbar=progress)\n    else:  # this uses just one CPU\n        if progress:\n            tqdm.pandas(desc=self.short_name, unit=' models',\n                        bar_format='{l_bar}{bar} [{n_fmt}/{total_fmt}; {rate_noinv_fmt}]')\n            ts = data_df.progress_apply(self.__ts_helper, args=(p,), axis=1)\n        else:\n            ts = data_df.apply(self.__ts_helper, args=(p,), axis=1)\n\n    match data:\n        case dict() if expand:\n            data_df['ts'] = ts\n            return data_df\n        case dict():\n            return ts.to_list()\n        case pd.DataFrame() if inplace:\n            data_df['ts'] = ts\n            return None\n        case pd.DataFrame():\n            return ts.rename('ts', inplace=True)\n        case xr.DataArray():\n            data.values = ts.to_numpy().reshape(data.shape)\n            return None\n        case _:\n            raise AssertionError('This code should never be reached - unsupported input data '\n                                 f'type of {type(data)}.')\n</code></pre>"},{"location":"api_reference/#echosms.PSMSModel.calculate_ts_single","title":"<code>calculate_ts_single(medium_c, medium_rho, a, b, theta, f, boundary_type, target_c=None, target_rho=None, validate_parameters=True)</code>","text":"<p>Prolate spheroid modal series (PSMS) solution model.</p> PARAMETER DESCRIPTION <code>medium_c</code> <p>Sound speed in the fluid medium surrounding the target [m/s].</p> <p> TYPE: <code>float</code> </p> <code>medium_rho</code> <p>Density of the fluid medium surrounding the target [kg/m\u00b3].</p> <p> TYPE: <code>float</code> </p> <code>a</code> <p>Prolate spheroid major axis radius [m].</p> <p> TYPE: <code>float</code> </p> <code>b</code> <p>Prolate spheroid minor axis radius [m].</p> <p> TYPE: <code>float</code> </p> <code>theta</code> <p>Pitch angle to calculate the scattering as per the echoSMs coordinate system [\u00b0].</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency to calculate the scattering at [Hz].</p> <p> TYPE: <code>float</code> </p> <code>boundary_type</code> <p>The model type. Supported model types are given in the <code>boundary_types</code> class variable.</p> <p> TYPE: <code>boundary_type</code> </p> <code>target_c</code> <p>Sound speed in the fluid inside the target [m/s]. Only required for <code>boundary_type</code> of <code>fluid_filled</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>target_rho</code> <p>Density of the fluid inside the target [kg/m\u00b3]. Only required for <code>boundary_type</code> of <code>fluid_filled</code>.</p> <p> TYPE: <code>float</code> DEFAULT: <code>None</code> </p> <code>validate_parameters</code> <p>Whether to validate the input parameters.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The target strength (re 1 m\u00b2) of the target [dB].</p> Notes <p>The backscattered target strength of a pressure release or fluid-filled prolate spheroid is calculated using the PSMS method of Furusawa (1988) and corrections in Furusawa et al. (1994).</p> References <p>Furusawa, M. (1988). \"Prolate spheroidal models for predicting general     trends of fish target strength,\" J. Acoust. Soc. Jpn. 9, 13-24.     https://doi.org/10.1250/ast.9.13</p> <p>Furusawa, M., Miyanohana, Y., Ariji, M., and Sawada, Y. (1994).     \u201cPrediction of krill target strength by liquid prolate spheroid     model,\u201d Fish. Sci., 60, 261-265. https://doi.org/10.2331/FISHSCI.60.261</p> Source code in <code>src/echosms/psmsmodel.py</code> <pre><code>def calculate_ts_single(self, medium_c, medium_rho, a, b, theta, f, boundary_type: bt,\n                        target_c=None, target_rho=None, validate_parameters=True):\n    \"\"\"Prolate spheroid modal series (PSMS) solution model.\n\n    Parameters\n    ----------\n    medium_c : float\n        Sound speed in the fluid medium surrounding the target [m/s].\n    medium_rho : float\n        Density of the fluid medium surrounding the target [kg/m\u00b3].\n    a : float\n        Prolate spheroid major axis radius [m].\n    b : float\n        Prolate spheroid minor axis radius [m].\n    theta : float\n        Pitch angle to calculate the scattering as per the echoSMs\n        [coordinate system](https://ices-tools-dev.github.io/echoSMs/\n        conventions/#coordinate-systems) [\u00b0].\n    f : float\n        Frequency to calculate the scattering at [Hz].\n    boundary_type :\n        The model type. Supported model types are given in the `boundary_types` class variable.\n    target_c : float\n        Sound speed in the fluid inside the target [m/s].\n        Only required for `boundary_type` of ``fluid_filled``.\n    target_rho : float\n        Density of the fluid inside the target [kg/m\u00b3].\n        Only required for `boundary_type` of ``fluid_filled``.\n    validate_parameters : bool\n        Whether to validate the input parameters.\n\n    Returns\n    -------\n    : float\n        The target strength (re 1 m\u00b2) of the target [dB].\n\n    Notes\n    -----\n    The backscattered target strength of a pressure release or fluid-filled prolate spheroid\n    is calculated using the PSMS method of Furusawa (1988) and corrections in\n    Furusawa et al. (1994).\n\n    References\n    ----------\n    Furusawa, M. (1988). \"Prolate spheroidal models for predicting general\n        trends of fish target strength,\" J. Acoust. Soc. Jpn. 9, 13-24.\n        &lt;https://doi.org/10.1250/ast.9.13&gt;\n\n    Furusawa, M., Miyanohana, Y., Ariji, M., and Sawada, Y. (1994).\n        \u201cPrediction of krill target strength by liquid prolate spheroid\n        model,\u201d Fish. Sci., 60, 261-265. &lt;https://doi.org/10.2331/FISHSCI.60.261&gt;\n    \"\"\"\n    if validate_parameters:\n        self.validate_parameters(locals())\n\n    if boundary_type not in self.boundary_types:\n        raise ValueError(f'The {self.long_name} model does not support '\n                         f'a model type of \"{boundary_type}\".')\n\n    xim = (1.0 - (b/a)**2)**(-0.5)\n    q = a/xim  # semi-focal length\n\n    km = wavenumber(medium_c, f)\n    hm = km*q\n\n    if boundary_type == bt.fluid_filled:\n        g = target_rho / medium_rho\n        ht = wavenumber(target_c, f)*q\n        simplified = False\n        # Note: we can implement simpler equations if sound speeds are\n        # similar between the medium and the target. The simplified\n        # equations are quicker, so it is worth to do.\n        # But, it appears that target_c \u2248 medium_c is not the only requirement for\n        # the simplification to work well - see section 4.1.1 in:\n        #\n        # Gonzalez, J. D., Lavia, E. F., Blanc, S., &amp; Prario, I. (2016).\n        # Acoustic scattering by prolate and oblate liquid spheroids.\n        # Proceedings of the 22nd International Congress on Acoustics.\n        # Acoustics for the 21st Century, Buenos Aires.\n        #\n        # So, for the moment, the simplification is turned off.\n\n        # if abs(1.0-target_c/medium_c) &lt;= 0.01:\n        #    simplified = True\n\n    # Phi, the roll angle is fixed for this implementation\n    phi_inc = np.pi  # incident direction\n    phi_sca = np.pi + phi_inc  # scattered direction\n\n    theta_inc = np.deg2rad(theta)  # incident direction\n    theta_sca = np.pi - theta_inc  # scattered direction\n\n    # Approximate limits on the summations. These come from Furusawa (1988), but other\n    # implementations of this code use more complex functions to calculate the maximum orders\n    # of spheroidal wave functions to calculate. It is also feasible to work to a defined\n    # convergence level. This is a potenital future improvement.\n    m_max = int(np.ceil(2*km*b))  # +1\n    n_max = int(m_max + np.ceil(hm/2))  # +3\n\n    f_sca = 0.0\n    for m in range(m_max+1):\n        epsilon_m = Neumann(m)\n        cos_term = np.cos(m*(phi_sca - phi_inc))\n\n        if boundary_type == bt.fluid_filled and not simplified:\n            Am = PSMSModel._fluidfilled(m, n_max, hm, ht, xim, g, theta_inc)\n\n        for n_i, n in enumerate(range(m, n_max+1)):\n            # Use the normalisation offered by spheroidalwavefunctions.pro_ang1() because\n            # it removes the need to calculate a normalisation factor (N_mn in Furusawa, 1998).\n            # This is because the pro_ang1(norm=True) norm is unity.\n            Smn_inc, _ = pro_ang1(m, n, hm, np.cos(theta_inc), norm=True)\n            Smn_sca, _ = pro_ang1(m, n, hm, np.cos(theta_sca), norm=True)\n\n            # FYI, the code used to use the Meixner-Sch\u00e4fke normalisation scheme for the\n            # angular function of the first kind (eqn 21.7.11 in Abramowitz, M., and Stegun,\n            # I. A. (1964). Handbook of Mathematical Functions with Formulas, Graphs, and\n            # Mathematical Tables # (Dover, New York), 10th ed.\n            # N_mn = 2/(2*n+1) * factorial(n+m) / factorial(n-m)\n\n            R1m, dR1m = pro_rad1(m, n, hm, xim)\n            R2m, dR2m = pro_rad2(m, n, hm, xim)\n\n            match boundary_type:\n                case bt.fluid_filled:\n                    if simplified:\n                        E1, E3 = PSMSModel._fluidfilled_Emn(m, n, n, hm, ht, xim, g)\n                        Amn = -E1/E3\n                    else:\n                        Amn = Am[n_i][0]\n                case bt.pressure_release:\n                    Amn = -R1m/(R1m + 1j*R2m)\n                case bt.fixed_rigid:\n                    Amn = -dR1m/(dR1m + 1j*dR2m)\n\n            f_sca += epsilon_m * Smn_inc * Amn * Smn_sca * cos_term\n\n    return 20*np.log10(np.abs(-2j / km * f_sca))\n</code></pre>"},{"location":"api_reference/#echosms.PSMSModel.validate_parameters","title":"<code>validate_parameters(params)</code>","text":"<p>Validate the model parameters.</p> <p>See here for calling details.</p> Source code in <code>src/echosms/psmsmodel.py</code> <pre><code>def validate_parameters(self, params):\n    \"\"\"Validate the model parameters.\n\n    See [here][echosms.ScatterModelBase.validate_parameters] for calling details.\n    \"\"\"\n    p = as_dict(params)\n    super()._present_and_in(p, ['boundary_type'], self.boundary_types)\n    super()._present_and_positive(p, ['medium_c', 'medium_rho', 'a', 'b', 'f'])\n\n    types = np.unique(np.atleast_1d(p['boundary_type']))\n    for t in types:\n        if t == bt.fluid_filled:\n            super()._present_and_positive(p, ['target_c', 'target_rho'],\n                                          mask=p['boundary_type'] == t)\n</code></pre>"},{"location":"api_reference/#utilities","title":"Utilities","text":""},{"location":"api_reference/#echosms.BenchmarkData","title":"<code>echosms.BenchmarkData()</code>","text":"<p>Convenient interface to the benchmark dataset.</p> <p>This dataset contains the benchmark TS results from Jech et al. (2015).</p> Notes <p>The column names in the source benchmark files have been changed to be the same as those used in the ReferenceModels model definitions.</p> References <p>Jech, J.M., Horne, J.K., Chu, D., Demer, D.A., Francis, D.T.I., Gorska, N., Jones, B., Lavery, A.C., Stanton, T.K., Macaulay, G.J., Reeder, D.B., Sawada, K., 2015. Comparisons among ten models of acoustic backscattering used in aquatic ecosystem research. Journal of the Acoustical Society of America 138, 3742-3764. https://doi.org/10.1121/1.4937607</p> Source code in <code>src/echosms/benchmarkdata.py</code> <pre><code>def __init__(self):\n\n    data_directory = Path(__file__).parent/Path('resources')/Path('BenchMark_Data')\n\n    angle_data_file = data_directory/'Benchmark_Angle_TS.csv'\n    freq_data_file = data_directory/'Benchmark_Frequency_TS.csv'\n\n    self.angle_dataset = pd.read_csv(angle_data_file)\n    self.freq_dataset = pd.read_csv(freq_data_file)\n\n    # Change the column names to match the reference model names used in ReferenceModels\n    self.angle_dataset.rename(columns=BenchmarkData.a_rename, inplace=True)\n    self.freq_dataset.rename(columns=BenchmarkData.f_rename, inplace=True)\n\n    self.freq_dataset['frequency (kHz)'] *= 1e3  # want Hz not kHz\n\n    # Remove units from the column names (we have the echoSMs units convention instead)\n    self.freq_dataset.rename(columns={'frequency (kHz)': 'frequency'}, inplace=True)\n    self.angle_dataset.rename(columns={'angle (deg)': 'angle'}, inplace=True)\n\n    self.angle_dataset.set_index('angle', inplace=True)\n    self.freq_dataset.set_index('frequency', inplace=True)\n</code></pre>"},{"location":"api_reference/#echosms.BenchmarkData.angle_as_dataframe","title":"<code>angle_as_dataframe()</code>","text":"<p>Provide the angle benchmark dataset as a Pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Dataframe containing the benchmark data.</p> Source code in <code>src/echosms/benchmarkdata.py</code> <pre><code>def angle_as_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"Provide the angle benchmark dataset as a Pandas DataFrame.\n\n    Returns\n    -------\n    :\n        Dataframe containing the benchmark data.\n    \"\"\"\n    return self.angle_dataset\n</code></pre>"},{"location":"api_reference/#echosms.BenchmarkData.angle_data","title":"<code>angle_data(name)</code>","text":"<p>Provide the benchmark TS values verses angle for the <code>name</code> model.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the benchmark model (available from <code>angle_names()</code>).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Tuple containing the angles (\u00b0) and TS (dB) for the requested benchmark model.</p> Source code in <code>src/echosms/benchmarkdata.py</code> <pre><code>def angle_data(self, name: str) -&gt; tuple:\n    \"\"\"Provide the benchmark TS values verses angle for the `name` model.\n\n    Parameters\n    ----------\n    name :\n        The name of the benchmark model (available from `angle_names()`).\n\n    Returns\n    -------\n    :\n        Tuple containing the angles (\u00b0) and TS (dB) for the requested benchmark model.\n    \"\"\"\n    if name not in self.angle_names():\n        raise ValueError(f'The requested model ({name}) is not in the angle benchmark dataset.')\n    return (self.angle_dataset.index.values, self.angle_dataset[name].values)\n</code></pre>"},{"location":"api_reference/#echosms.BenchmarkData.angle_names","title":"<code>angle_names()</code>","text":"<p>Provide the model names for the angle benchmark data.</p> RETURNS DESCRIPTION <code>list</code> <p>List of model names.</p> Source code in <code>src/echosms/benchmarkdata.py</code> <pre><code>def angle_names(self) -&gt; list:\n    \"\"\"Provide the model names for the angle benchmark data.\n\n    Returns\n    -------\n    :\n        List of model names.\n\n    \"\"\"\n    return self.angle_dataset.columns.values.tolist()\n</code></pre>"},{"location":"api_reference/#echosms.BenchmarkData.freq_as_dataframe","title":"<code>freq_as_dataframe()</code>","text":"<p>Provide the frequency benchmark dataset as a Pandas DataFrame.</p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Dataframe containing the benchmark data.</p> Source code in <code>src/echosms/benchmarkdata.py</code> <pre><code>def freq_as_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"Provide the frequency benchmark dataset as a Pandas DataFrame.\n\n    Returns\n    -------\n    :\n        Dataframe containing the benchmark data.\n    \"\"\"\n    return self.freq_dataset\n</code></pre>"},{"location":"api_reference/#echosms.BenchmarkData.freq_data","title":"<code>freq_data(name)</code>","text":"<p>Provide the benchmark TS values verses frequency for the <code>name</code> model.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the benchmark model (available from <code>freq_names()</code>).</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Tuple containing the frequencies (Hz) and TS (dB) for the requested benchmark model.</p> Source code in <code>src/echosms/benchmarkdata.py</code> <pre><code>def freq_data(self, name: str) -&gt; tuple:\n    \"\"\"Provide the benchmark TS values verses frequency for the `name` model.\n\n    Parameters\n    ----------\n    name :\n        The name of the benchmark model (available from `freq_names()`).\n\n    Returns\n    -------\n    :\n        Tuple containing the frequencies (Hz) and TS (dB) for the requested benchmark model.\n    \"\"\"\n    if name not in self.freq_names():\n        raise ValueError(f'The requested model ({name}) '\n                         'is not in the frequency benchmark dataset.')\n    return (self.freq_dataset.index.values, self.freq_dataset[name].values)\n</code></pre>"},{"location":"api_reference/#echosms.BenchmarkData.freq_names","title":"<code>freq_names()</code>","text":"<p>Provide the model names for the frequency benchmark data.</p> RETURNS DESCRIPTION <code>list</code> <p>List of model names.</p> Source code in <code>src/echosms/benchmarkdata.py</code> <pre><code>def freq_names(self) -&gt; list:\n    \"\"\"Provide the model names for the frequency benchmark data.\n\n    Returns\n    -------\n    :\n        List of model names.\n    \"\"\"\n    return self.freq_dataset.columns.values.tolist()\n</code></pre>"},{"location":"api_reference/#echosms.ReferenceModels","title":"<code>echosms.ReferenceModels()</code>","text":"<p>Provide access to reference scattering model parameters.</p> <p>Reference models are the models and parameters defined in Jech et al. (2015). The parameters are stored in a TOML-formatted file in the echoSMs repository and this class provides easy access to the data in that file. Additional reference models may be defined in the future and added to the TOML file (for example, entries have been added for all known calibration sphere sizes).</p> ATTRIBUTE DESCRIPTION <code>definitions</code> <p>A dict representation of the <code>target definitions.toml</code> file.</p> <p> TYPE: <code>dict</code> </p> RAISES DESCRIPTION <code>TOMLDecodeError</code> <p>If the <code>target definitions.toml</code> file is not valid TOML.</p> <code>KeyError</code> <p>If the <code>target definitions.toml</code> file has multiple target entries with the same name.</p> References <p>Jech, J.M., Horne, J.K., Chu, D., Demer, D.A., Francis, D.T.I., Gorska, N., Jones, B., Lavery, A.C., Stanton, T.K., Macaulay, G.J., Reeder, D.B., Sawada, K., 2015. Comparisons among ten models of acoustic backscattering used in aquatic ecosystem research. Journal of the Acoustical Society of America 138, 3742\u20133764. https://doi.org/10.1121/1.4937607</p> Source code in <code>src/echosms/referencemodels.py</code> <pre><code>def __init__(self):\n    self.defs_filename = Path(__file__).parent/Path('resources')/Path('target definitions.toml')\n\n    self.definitions = []\n\n    with open(self.defs_filename, 'rb') as f:\n        try:\n            self.definitions = tomllib.load(f)\n        except tomllib.TOMLDecodeError as e:\n            raise SyntaxError(f'Error while parsing file \"{self.defs_filename.name}\"') from e\n\n    # Flag duplicate target names\n    pda = pd.Series(self.names())\n    duplicates = list(pda[pda.duplicated()])\n    if duplicates:\n        raise KeyError(f'The \"{self.defs_filename.name}\" file has multiple targets '\n                       f'with the same name: '+', '.join(duplicates))\n\n    # Substitute parameters names in the target section by the values of those\n    # parameters.\n    for t in self.definitions['target']:\n        for k, v in t.items():\n            try:\n                t[k] = self.definitions['parameters'][v]\n            except (KeyError, TypeError):\n                pass\n</code></pre>"},{"location":"api_reference/#echosms.ReferenceModels.names","title":"<code>names()</code>","text":"<p>Names of all model definitions.</p> RETURNS DESCRIPTION <code>iterable of str</code> <p>All model names in the <code>target definitions.toml</code> file.</p> Source code in <code>src/echosms/referencemodels.py</code> <pre><code>def names(self):\n    \"\"\"Names of all model definitions.\n\n    Returns\n    -------\n    : iterable of str\n        All model names in the ``target definitions.toml`` file.\n    \"\"\"\n    return [n['name'] for n in self.definitions['target']]\n</code></pre>"},{"location":"api_reference/#echosms.ReferenceModels.parameters","title":"<code>parameters(name)</code>","text":"<p>Model parameters for a particular model.</p> <p>Model parameters are a subset of the model specification where the metadata items have been removed.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of a model in the <code>target definitions.toml</code> file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The model parameters for the requested model or an empty dict if no model with that name.</p> Source code in <code>src/echosms/referencemodels.py</code> <pre><code>def parameters(self, name: str) -&gt; dict:\n    \"\"\"Model parameters for a particular model.\n\n    Model parameters are a subset of the model specification where the metadata items have\n    been removed.\n\n    Parameters\n    ----------\n    name :\n        The name of a model in the ``target definitions.toml`` file.\n\n    Returns\n    -------\n    :\n        The model parameters for the requested model or an empty dict if no model with\n        that name.\n\n    \"\"\"\n    s = self.specification(name)\n\n    if not s:\n        return {}\n\n    # Remove the entries that are not parameters\n    p = s.copy()\n    for k in ['name', 'shape', 'description', 'source', 'benchmark_model']:\n        p.pop(k, None)\n    return p\n</code></pre>"},{"location":"api_reference/#echosms.ReferenceModels.specification","title":"<code>specification(name)</code>","text":"<p>Model definitions for a particular model.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of a model in the <code>target definitions.toml</code> file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The model definitions for the requested model or an empty dict if no model with that name.</p> Source code in <code>src/echosms/referencemodels.py</code> <pre><code>def specification(self, name: str) -&gt; dict:\n    \"\"\"Model definitions for a particular model.\n\n    Parameters\n    ----------\n    name :\n        The name of a model in the ``target definitions.toml`` file.\n\n    Returns\n    -------\n    :\n        The model definitions for the requested model or an empty dict if no model\n        with that name.\n    \"\"\"\n    s = [t for t in self.definitions['target'] if t['name'] == name]\n    if not s:\n        return {}\n\n    return s[0]\n</code></pre>"},{"location":"api_reference/#echosms.JechEtAlData","title":"<code>echosms.JechEtAlData()</code>","text":"<p>Simple access to all model results in Jech et al (2015).</p> ATTRIBUTE DESCRIPTION <code>data</code> <p>One entry in the dict for each model results file.</p> <p> TYPE: <code>dict[DataFrame]</code> </p> <code>data_directory</code> <p>The directory containing the model results files.</p> <p> TYPE: <code>Path</code> </p> References <p>Jech, J.M., Horne, J.K., Chu, D., Demer, D.A., Francis, D.T.I., Gorska, N., Jones, B., Lavery, A.C., Stanton, T.K., Macaulay, G.J., Reeder, D.B., Sawada, K., 2015. Comparisons among ten models of acoustic backscattering used in aquatic ecosystem research. Journal of the Acoustical Society of America 138, 3742-3764. https://doi.org/10.1121/1.4937607</p> Source code in <code>src/echosms/jechetaldata.py</code> <pre><code>def __init__(self):\n    self.data_directory = Path(__file__).parent/Path('resources')/Path('Jechetal_allmodels')\n    self.data = {f.stem: pd.read_csv(f) for f in self.data_directory.glob('*.csv')}\n</code></pre>"},{"location":"api_reference/#echosms.utils","title":"<code>echosms.utils</code>","text":"<p>Miscellaneous utility functions.</p>"},{"location":"api_reference/#echosms.utils.boundary_type","title":"<code>boundary_type</code>","text":"<p>               Bases: <code>StrEnum</code></p> <p>Scattering model boundary types.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.fixed_rigid","title":"<code>fixed_rigid = 'fixed-rigid'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fixed-rigid boundary condition, where the normal velocity is zero at the object's boundary.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.pressure_release","title":"<code>pressure_release = 'pressure-release'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Pressure-release boundary condition, where the acoustic pressure is zero at the object's boundary.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.fluid_filled","title":"<code>fluid_filled = 'fluid-filled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fluid-filled boundary condition, where the acoustic pressure and normal velocity are both non-zero at the object's boundary.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.elastic","title":"<code>elastic = 'elastic'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The scattering object supports compressional and shear waves.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.fluid_shell_fluid_interior","title":"<code>fluid_shell_fluid_interior = 'fluid shell fluid interior'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The object has a fluid interior surrounded by a fluid shell.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.fluid_shell_pressure_release_interior","title":"<code>fluid_shell_pressure_release_interior = 'fluid shell pressure release interior'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The object has a pressure release interior surrounded by a fluid shell.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.hard","title":"<code>hard = 'fixed-rigid'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A synonym for <code>fixed_rigid</code>.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.soft","title":"<code>soft = 'pressure-release'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A synonym for <code>pressure_release</code>.</p>"},{"location":"api_reference/#echosms.utils.boundary_type.fluid","title":"<code>fluid = 'fluid-filled'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>A synonym for <code>fluid_filled</code>.</p>"},{"location":"api_reference/#echosms.utils.theoretical_Sa","title":"<code>theoretical_Sa(ts, eba, r, nautical=False)</code>","text":"<p>Theoretical area backscattering strength (S\u2090) of a target.</p> PARAMETER DESCRIPTION <code>ts</code> <p>The target strength of the object [dB re 1 m\u00b2].</p> <p> TYPE: <code>float | ndarray</code> </p> <code>eba</code> <p>Ten times the logarithm to the base 10 of the transducer's equivalent two-way beam angle (\u03c8, sr). In formula form this is: eba = 10 log<sub>10</sub>(\u03c8) dB (re 1 sr).</p> <p> TYPE: <code>float</code> </p> <code>r</code> <p>The range from the transducer to the target [m]. Used for acoustic beam spreading.</p> <p> TYPE: <code>float</code> </p> <code>nautical</code> <p>If <code>True</code>, the nautical area scattering strength (S<sub>A</sub>) is returned instead of the area backscattering strength (S\u2090).</p> <p> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>float | ndarray</code> <p>The theoretical S\u2090 [dB re 1 m\u00b2 m\u207b\u00b2] or S<sub>A</sub> [dB re 1 m\u00b2 nmi\u207b\u00b2] of the input <code>ts</code>.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If an input value is out of bounds.</p> Notes <p>While the calculation is valid for any target, the theoretical area strengths are most relevant when calibrating an echosounder using a sphere. The difference between the theoretical and measured can be used to calculate the calibration gain for an echosounder (when the sphere is on-axis).</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def theoretical_Sa(ts: float | np.ndarray, eba: float, r: float, nautical=False)\\\n                   -&gt; float | np.ndarray:\n    \"\"\"Theoretical area backscattering strength (S\u2090) of a target.\n\n    Parameters\n    ----------\n    ts :\n        The target strength of the object [dB re 1 m\u00b2].\n    eba :\n        Ten times the logarithm to the base 10 of the transducer's equivalent two-way beam angle (\u03c8, sr).\n        In formula form this is: eba = 10 log&lt;sub&gt;10&lt;/sub&gt;(\u03c8) dB (re 1 sr).\n    r :\n        The range from the transducer to the target [m]. Used for acoustic beam spreading.\n    nautical :\n        If `True`, the nautical area scattering strength (S&lt;sub&gt;A&lt;/sub&gt;) is returned instead of the\n        area backscattering strength (S\u2090).\n\n    Returns\n    -------\n    :\n        The theoretical S\u2090 [dB re 1 m\u00b2 m\u207b\u00b2] or S&lt;sub&gt;A&lt;/sub&gt; [dB re 1 m\u00b2 nmi\u207b\u00b2] of the input `ts`.\n\n    Raises\n    ------\n    ValueError\n        If an input value is out of bounds.\n\n    Notes\n    -----\n    While the calculation is valid for any target, the theoretical area strengths are most relevant\n    when calibrating an echosounder using a sphere. The difference between\n    the theoretical and measured can be used to calculate the calibration gain for an\n    echosounder (when the sphere is on-axis).\n    \"\"\"\n    if eba &gt; 0.0:\n        raise ValueError('A positive eba value is not supported.')\n    if r &lt;= 0.0:\n        raise ValueError('An r value less than or equal to 0 is not supported.')\n\n    factor = 10.0*np.log10(4.0*\u03c0*1852.0**2) if nautical else 0.0\n    return ts - eba - 20.0*np.log10(r) + factor\n</code></pre>"},{"location":"api_reference/#echosms.utils.Neumann","title":"<code>Neumann(m)</code>","text":"<p>Neumann number.</p> PARAMETER DESCRIPTION <code>m</code> <p>The input integer.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The Neumann number.</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def Neumann(m: int) -&gt; int:\n    \"\"\"Neumann number.\n\n    Parameters\n    ----------\n    m :\n        The input integer.\n\n    Returns\n    -------\n    :\n        The Neumann number.\n    \"\"\"\n    if m == 0:\n        return 1\n    return 2\n</code></pre>"},{"location":"api_reference/#echosms.utils.wavenumber","title":"<code>wavenumber(c, f)</code>","text":"<p>Calculate the acoustic wavenumber.</p> PARAMETER DESCRIPTION <code>c</code> <p>Sound speed [m/s]</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency [Hz]</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The acoustic wavenumber [m\u207b\u00b9].</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def wavenumber(c: float, f: float) -&gt; float:\n    \"\"\"Calculate the acoustic wavenumber.\n\n    Parameters\n    ----------\n    c :\n        Sound speed [m/s]\n\n    f :\n        Frequency [Hz]\n\n    Returns\n    -------\n    :\n        The acoustic wavenumber [m\u207b\u00b9].\n    \"\"\"\n    return 2*\u03c0*f/c\n</code></pre>"},{"location":"api_reference/#echosms.utils.wavelength","title":"<code>wavelength(c, f)</code>","text":"<p>Calculate the acoustic wavelength.</p> PARAMETER DESCRIPTION <code>c</code> <p>Sound speed [m/s]</p> <p> TYPE: <code>float</code> </p> <code>f</code> <p>Frequency [Hz]</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The acoustic wavelength [m].</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def wavelength(c: float, f: float) -&gt; float:\n    \"\"\"Calculate the acoustic wavelength.\n\n    Parameters\n    ----------\n    c :\n        Sound speed [m/s]\n\n    f :\n        Frequency [Hz]\n\n    Returns\n    -------\n    :\n        The acoustic wavelength [m].\n    \"\"\"\n    return c/f\n</code></pre>"},{"location":"api_reference/#echosms.utils.h1","title":"<code>h1(n, z, derivative=False)</code>","text":"<p>Spherical Hankel function of the first kind or its' derivative.</p> PARAMETER DESCRIPTION <code>n</code> <p>Order (n \u2265 0).</p> <p> TYPE: <code>int</code> </p> <code>z</code> <p>Argument of the Hankel function.</p> <p> TYPE: <code>float</code> </p> <code>derivative</code> <p>if True, the value of the derivative (rather than the function itself) is returned.</p> <p> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>complex</code> <p>Value of the spherical Hankel function</p> RAISES DESCRIPTION <code>ValueError</code> <p>For negative n values.</p> Notes <p>The value of the Hankel function is calculated from spherical Bessel functions [1].</p> <p>The derivative is computed from spherical Hankel functions [2].</p> References <p>[1] https://dlmf.nist.gov/10.47.E10</p> <p>[2] https://dlmf.nist.gov/10.51.E2</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def h1(n: int, z: float, derivative=False) -&gt; complex:\n    \"\"\"Spherical Hankel function of the first kind or its' derivative.\n\n    Parameters\n    ----------\n    n :\n        Order (n \u2265 0).\n    z :\n        Argument of the Hankel function.\n    derivative :\n        if True, the value of the derivative (rather than the function itself) is returned.\n\n    Returns\n    -------\n    :\n        Value of the spherical Hankel function\n\n    Raises\n    ------\n    ValueError\n        For negative n values.\n\n    Notes\n    -----\n    The value of the Hankel function is calculated from spherical Bessel functions [1].\n\n    The derivative is computed from spherical Hankel functions [2].\n\n    References\n    ----------\n    [1] &lt;https://dlmf.nist.gov/10.47.E10&gt;\n\n    [2] &lt;https://dlmf.nist.gov/10.51.E2&gt;\n    \"\"\"\n    if n &lt; 0:\n        raise ValueError('Negative n values are not supported for spherical Hankel functions.')\n\n    if not derivative:\n        return spherical_jn(n, z) + 1j*spherical_yn(n, z)\n    return -h1(n+1, z) + (n/z) * h1(n, z)\n</code></pre>"},{"location":"api_reference/#echosms.utils.spherical_jnpp","title":"<code>spherical_jnpp(n, z)</code>","text":"<p>Second derivative of the spherical Bessel function.</p> PARAMETER DESCRIPTION <code>n</code> <p>Order (n \u2265 0)</p> <p> TYPE: <code>int</code> </p> <code>z</code> <p>Argument of the Bessel function.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The second derivative of the spherical Bessel function.</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def spherical_jnpp(n: int, z: float) -&gt; float:\n    \"\"\"Second derivative of the spherical Bessel function.\n\n    Parameters\n    ----------\n    n :\n        Order (n \u2265 0)\n    z :\n        Argument of the Bessel function.\n\n    Returns\n    -------\n    :\n        The second derivative of the spherical Bessel function.\n\n    \"\"\"\n    return 1./z**2 * ((n**2-n-z**2)*spherical_jn(n, z) + 2.*z*spherical_jn(n+1, z))\n</code></pre>"},{"location":"api_reference/#echosms.utils.split_dict","title":"<code>split_dict(d, s)</code>","text":"<p>Split a dict into two dicts based on a list of keys.</p> PARAMETER DESCRIPTION <code>d</code> <p>Dict to be split.</p> <p> TYPE: <code>dict</code> </p> <code>s</code> <p>List of dict keys to use for splitting <code>d</code>.</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>tuple(dict, dict)</code> <p>The <code>input</code> dict split into two dicts based on the keys in <code>s</code>. The first tuple item contains the items that do not have keys in <code>s</code>.</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def split_dict(d: dict, s: list) -&gt; tuple[dict, dict]:\n    \"\"\"Split a dict into two dicts based on a list of keys.\n\n    Parameters\n    ----------\n    d : dict\n        Dict to be split.\n\n    s: list\n        List of dict keys to use for splitting `d`.\n\n    Returns\n    -------\n    : tuple(dict, dict)\n        The `input` dict split into two dicts based on the keys in `s`. The first tuple item\n        contains the items that do not have keys in `s`.\n    \"\"\"\n    contains = {k: v for k, v in d.items() if k in s}\n    ncontains = {k: v for k, v in d.items() if k not in s}\n    return ncontains, contains\n</code></pre>"},{"location":"api_reference/#echosms.utils.as_dataarray","title":"<code>as_dataarray(params, no_expand=[])</code>","text":"<p>Convert model parameters from dict form to a Xarray DataArray.</p> PARAMETER DESCRIPTION <code>params</code> <p>The model parameters.</p> <p> TYPE: <code>dict</code> </p> <code>no_expand</code> <p>Key values of the non-expandable model parameters in <code>params</code>.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[]</code> </p> RETURNS DESCRIPTION <code>DataArray</code> <p>Returns a multi-dimensional DataArray generated from the Cartesian product of all expandable items in the input dict. Non-expandable items are added to the DataArray attrs property. Expandable items are those that can be sensibly expanded into DataArray coordinates. Not all models have non-expandable items. The array is named <code>ts</code>, the values are initialised to <code>nan</code>, the dimension names are the dict keys, and the coordinate variables are the dict values.</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def as_dataarray(params: dict, no_expand: list = []) -&gt; xr.DataArray:\n    \"\"\"Convert model parameters from dict form to a Xarray DataArray.\n\n    Parameters\n    ----------\n    params :\n        The model parameters.\n\n    no_expand :\n        Key values of the non-expandable model parameters in `params`.\n\n    Returns\n    -------\n    :\n        Returns a multi-dimensional DataArray generated from the Cartesian product of all\n        expandable items in the input dict. Non-expandable items are added to the DataArray\n        attrs property. Expandable items are those that can be sensibly expanded into\n        DataArray coordinates. Not all models have non-expandable items.\n        The array is named `ts`, the values are initialised to `nan`, the\n        dimension names are the dict keys, and the coordinate variables are the dict values.\n\n    \"\"\"\n    expand, nexpand = split_dict(params, no_expand)\n\n    # Convert scalars to iterables so xarray is happy\n    for k, v in expand.items():\n        if not isinstance(v, Iterable) or isinstance(v, str):\n            expand[k] = [v]\n\n    sz = [len(v) for k, v in expand.items()]\n    return xr.DataArray(data=np.full(sz, np.nan), coords=expand, name='ts',\n                        attrs={'units': 'dB', 'dB_reference': '1 m^2',\n                               'parameters': nexpand})\n</code></pre>"},{"location":"api_reference/#echosms.utils.as_dataframe","title":"<code>as_dataframe(params, no_expand=[])</code>","text":"<p>Convert model parameters from dict form to a Pandas DataFrame.</p> PARAMETER DESCRIPTION <code>params</code> <p>The model parameters.</p> <p> TYPE: <code>dict</code> </p> <code>no_expand</code> <p>Key values of the non-expandable model parameters in <code>params</code>.</p> <p> TYPE: <code>list</code> DEFAULT: <code>[]</code> </p> RETURNS DESCRIPTION <code>DataFrame</code> <p>Returns a Pandas DataFrame generated from the Cartesian product of all expandable items in the input dict. DataFrame column names are obtained from the dict keys. Non-expandable items are added to the DataFrame attrs property. Expandable items are those that can be sensibly expanded into DataFrame columns. Not all models have non-expandable items.</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def as_dataframe(params: dict, no_expand: list = []) -&gt; pd.DataFrame:\n    \"\"\"Convert model parameters from dict form to a Pandas DataFrame.\n\n    Parameters\n    ----------\n    params :\n        The model parameters.\n\n    no_expand :\n        Key values of the non-expandable model parameters in `params`.\n\n    Returns\n    -------\n    :\n        Returns a Pandas DataFrame generated from the Cartesian product of all expandable\n        items in the input dict. DataFrame column names are obtained from the dict keys.\n        Non-expandable items are added to the DataFrame attrs property. Expandable items are\n        those that can be sensibly expanded into DataFrame columns. Not all models have\n        non-expandable items.\n\n    \"\"\"\n    expand, nexpand = split_dict(params, no_expand)\n\n    # Use meshgrid to do the Cartesian product then create a Pandas DataFrame from that, having\n    # flattened the multidimensional arrays and using a dict to provide column names.\n    # This preserves the differing dtypes in each column compared to other ways of\n    # constructing the DataFrame).\n    df = pd.DataFrame({k: t.flatten()\n                       for k, t in zip(expand.keys(), np.meshgrid(*tuple(expand.values())))})\n    df.attrs = {'parameters': nexpand}\n    return df\n</code></pre>"},{"location":"api_reference/#echosms.utils.as_dict","title":"<code>as_dict(params)</code>","text":"<p>Convert model parameters from DataFrame or DataArray to dict.</p> PARAMETER DESCRIPTION <code>params</code> <p>The model parameters</p> <p> TYPE: <code>dict | DataFrame | DataArray</code> </p> RAISES DESCRIPTION <code>TypeError:</code> <p>If the input data type is not supported.</p> RETURNS DESCRIPTION <code>dict</code> <p>A dict containing the model parameters.</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def as_dict(params: dict | pd.DataFrame | xr.DataArray) -&gt; dict:\n    \"\"\"Convert model parameters from DataFrame or DataArray to dict.\n\n    Parameters\n    ----------\n    params:\n        The model parameters\n\n    Raises\n    ------\n    TypeError:\n        If the input data type is not supported.\n\n    Returns\n    -------\n    :\n        A dict containing the model parameters.\n    \"\"\"\n    if isinstance(params, dict):\n        return params\n\n    # Get the non-expandable model parameters\n    p = params.attrs['parameters'] if 'parameters' in params.attrs else {}\n\n    if isinstance(params, xr.DataArray):\n        return dict(zip(params.coords, params.indexes.values())) | p\n    elif isinstance(params, pd.DataFrame):\n        # params.attrs = {}  # otherwise to_dict() exposes a bug in pandas?\n        return params.to_dict(orient='series') | p\n\n    raise TypeError('Only dict, DataFrame, or DataArray are accepted.')\n</code></pre>"},{"location":"api_reference/#echosms.utils.pro_ang1","title":"<code>pro_ang1(m, n, c, eta, norm=False)</code>","text":"<p>Prolate spheroidal angular function of the first kind and derivative.</p> <p>Calculates the prolate spheroidal angular function of the first kind and its' derivative with respect to <code>eta</code>.</p> PARAMETER DESCRIPTION <code>m</code> <p>The order parameter (\u2265 0)</p> <p> TYPE: <code>int</code> </p> <code>n</code> <p>The degree parameter (\u2265 <code>m</code>).</p> <p> TYPE: <code>int</code> </p> <code>c</code> <p>The size parameter.</p> <p> TYPE: <code>float</code> </p> <code>eta</code> <p>The angular coordinate, \u03b7, where |\u03b7| \u2264 1.</p> <p> TYPE: <code>float</code> </p> <code>norm</code> <p>If <code>False</code>, returned values are not normalised (i.e., the Meixner-Sch\u00e4fke normlalisation scheme is used). For large <code>m</code> this norm becomes very large. If <code>True</code> the returned values are scaled by the square root of the normalisation of the corresponding Legendre function. This avoids the large values that occur when <code>norm</code> is <code>False</code>.</p> <p> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>tuple[float, float]</code> <p>The value of the prolate spheroidal angular function and its' derivative.</p> Notes <p>This method uses the prolate spheroidal wave function code for non complex arguments (van Buren &amp; Boisvert, 2002, and van Buren &amp; Boisvert, 2024), available on github. This code is in Fortran90 and was interfaced to Python using <code>numpy.f2py</code> then wrapped with the current method to provide a similar calling convention as the Scipy function of the same name.</p> References <p>Van Buren, A. L., &amp; Boisvert, J. E. (2002). Accurate calculation of prolate spheroidal radial functions of the first kind and their first derivatives. Quarterly of Applied Mathematics, 60(3), 589-599. https://doi.org/10.1090/qam/1914443</p> <p>Van Buren, A. L., &amp; Boisvert, J. E. (2004). Improved Calculation of Prolate Spheroidal Radial Functions of the Second Kind and Their First Derivatives. Quarterly of Applied Mathematics, 62(3), 493-507. https://doi.org/10.1090/qam/2086042</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def pro_ang1(m: int, n: int, c: float, eta: float, norm=False) -&gt; tuple[float, float]:\n    \"\"\"Prolate spheroidal angular function of the first kind and derivative.\n\n    Calculates the prolate spheroidal angular function of the first kind and its'\n    derivative with respect to `eta`.\n\n    Parameters\n    ----------\n    m :\n        The order parameter (\u2265 0)\n    n :\n        The degree parameter (\u2265 `m`).\n    c :\n        The size parameter.\n    eta :\n        The angular coordinate, \u03b7, where |\u03b7| \u2264 1.\n    norm :\n        If `False`, returned values are not normalised (i.e., the Meixner-Sch\u00e4fke normlalisation\n        scheme is used). For large `m` this norm becomes very large. If `True` the returned values\n        are scaled by the square root of the normalisation of the corresponding Legendre function.\n        This avoids the large values that occur when `norm` is `False`.\n\n    Returns\n    -------\n    :\n        The value of the prolate spheroidal angular function and its' derivative.\n\n    Notes\n    -----\n    This method uses the prolate spheroidal wave function code for non complex\n    arguments (van Buren &amp; Boisvert, 2002, and van Buren &amp; Boisvert, 2024), available on\n    [github](https://github.com/MathieuandSpheroidalWaveFunctions). This code is in Fortran90\n    and was interfaced to Python using `numpy.f2py` then wrapped with the current method to\n    provide a similar calling convention as the Scipy function of the same name.\n\n    References\n    ----------\n    Van Buren, A. L., &amp; Boisvert, J. E. (2002). Accurate calculation of prolate spheroidal\n    radial functions of the first kind and their first derivatives. Quarterly of Applied\n    Mathematics, 60(3), 589-599. &lt;https://doi.org/10.1090/qam/1914443&gt;\n\n    Van Buren, A. L., &amp; Boisvert, J. E. (2004). Improved Calculation of Prolate Spheroidal\n    Radial Functions of the Second Kind and Their First Derivatives. Quarterly of Applied\n    Mathematics, 62(3), 493-507. &lt;https://doi.org/10.1090/qam/2086042&gt;\n    \"\"\"\n    if m &lt; 0:\n        raise ValueError('The m parameter must be positive.')\n    if n &lt; m:\n        raise ValueError('The n parameter must be greater than or equal to the m parameter.')\n    if abs(eta) &gt; 1.0:\n        raise ValueError('The eta parameter must be less than or equal to 1')\n\n    a = prolate_swf.profcn(c=c, m=m, lnum=n-m+2, x1=0.0, ioprad=0, iopang=2,\n                           iopnorm=int(norm), arg=[eta])\n    p = swf_t._make(a)\n    if np.isnan(p.s1c[n-m]) or np.isnan(p.s1dc[n-m]):\n        # print('Root - trying again.')\n        a = prolate_swf.profcn(c=c, m=m, lnum=n-m+2, x1=0.0, ioprad=0, iopang=2,\n                               iopnorm=int(norm), arg=[eta+sys.float_info.epsilon])\n        p = swf_t._make(a)\n\n    s = p.s1c[n-m] * np.float_power(10.0, p.is1e[n-m])\n    sp = p.s1dc[n-m] * np.float_power(10.0, p.is1de[n-m])\n\n    return s[0], sp[0]\n</code></pre>"},{"location":"api_reference/#echosms.utils.pro_rad1","title":"<code>pro_rad1(m, n, c, xi)</code>","text":"<p>Prolate spheroidal radial function of the first kind and derivative.</p> <p>Calculates the prolate spheroidal radial function of the first kind and its' derivative with respect to <code>xi</code>.</p> PARAMETER DESCRIPTION <code>m</code> <p>The order parameter (\u2265 0).</p> <p> TYPE: <code>int</code> </p> <code>n</code> <p>The degree parameter (\u2265 <code>m</code>).</p> <p> TYPE: <code>int</code> </p> <code>c</code> <p>The size parameter.</p> <p> TYPE: <code>float</code> </p> <code>xi</code> <p>The radial coordinate, \u03be, where \u03be \u2265 1.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>tuple[float, float]</code> <p>The value of the prolate spheroidal radial function and its' derivative.</p> Notes <p>This method uses the prolate spheroidal wave function code for non complex arguments (van Buren &amp; Boisvert, 2002, and van Buren &amp; Boisvert, 2024), available on github. This code is in Fortran90 and was interfaced to Python using <code>numpy.f2py</code> then wrapped with the current method to provide a similar calling convention as the Scipy function of the same name.</p> References <p>Van Buren, A. L., &amp; Boisvert, J. E. (2002). Accurate calculation of prolate spheroidal radial functions of the first kind and their first derivatives. Quarterly of Applied Mathematics, 60(3), 589-599. https://doi.org/10.1090/qam/1914443</p> <p>Van Buren, A. L., &amp; Boisvert, J. E. (2004). Improved Calculation of Prolate Spheroidal Radial Functions of the Second Kind and Their First Derivatives. Quarterly of Applied Mathematics, 62(3), 493-507. https://doi.org/10.1090/qam/2086042</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def pro_rad1(m: int, n: int, c: float, xi: float) -&gt; tuple[float, float]:\n    \"\"\"Prolate spheroidal radial function of the first kind and derivative.\n\n    Calculates the prolate spheroidal radial function of the first kind and its'\n    derivative with respect to `xi`.\n\n    Parameters\n    ----------\n    m :\n        The order parameter (\u2265 0).\n    n :\n        The degree parameter (\u2265 `m`).\n    c :\n        The size parameter.\n    xi :\n        The radial coordinate, \u03be, where \u03be \u2265 1.\n\n    Returns\n    -------\n    :\n        The value of the prolate spheroidal radial function and its' derivative.\n\n    Notes\n    -----\n    This method uses the prolate spheroidal wave function code for non complex\n    arguments (van Buren &amp; Boisvert, 2002, and van Buren &amp; Boisvert, 2024), available on\n    [github](https://github.com/MathieuandSpheroidalWaveFunctions). This code is in Fortran90\n    and was interfaced to Python using `numpy.f2py` then wrapped with the current method to\n    provide a similar calling convention as the Scipy function of the same name.\n\n    References\n    ----------\n    Van Buren, A. L., &amp; Boisvert, J. E. (2002). Accurate calculation of prolate spheroidal\n    radial functions of the first kind and their first derivatives. Quarterly of Applied\n    Mathematics, 60(3), 589-599. &lt;https://doi.org/10.1090/qam/1914443&gt;\n\n    Van Buren, A. L., &amp; Boisvert, J. E. (2004). Improved Calculation of Prolate Spheroidal\n    Radial Functions of the Second Kind and Their First Derivatives. Quarterly of Applied\n    Mathematics, 62(3), 493-507. &lt;https://doi.org/10.1090/qam/2086042&gt;\n    \"\"\"\n    if m &lt; 0:\n        raise ValueError('The m parameter must be positive.')\n    if n &lt; m:\n        raise ValueError('The n parameter must be greater than or equal to the m parameter.')\n    if xi &lt; 1.0:\n        raise ValueError('The xi parameter must be greater than or equal to 1')\n\n    a = prolate_swf.profcn(c=c, m=m, lnum=n-m+2, x1=xi-1.0, ioprad=1, iopang=0, iopnorm=0, arg=[0])\n    p = swf_t._make(a)\n    s = p.r1c * np.float_power(10.0, p.ir1e)\n    sp = p.r1dc * np.float_power(10.0, p.ir1de)\n\n    return s[n-m], sp[n-m]\n</code></pre>"},{"location":"api_reference/#echosms.utils.pro_rad2","title":"<code>pro_rad2(m, n, c, xi)</code>","text":"<p>Prolate spheroidal radial function of the second kind and derivative.</p> <p>Calculates the prolate spheroidal radial function of the second kind and its' derivative with respect to <code>xi</code>.</p> PARAMETER DESCRIPTION <code>m</code> <p>The order parameter (\u2265 0).</p> <p> TYPE: <code>int</code> </p> <code>n</code> <p>The degree parameter (\u2265 <code>m</code>).</p> <p> TYPE: <code>int</code> </p> <code>c</code> <p>The size parameter.</p> <p> TYPE: <code>float</code> </p> <code>xi</code> <p>The radial coordinate, \u03be, where \u03be \u2265 1.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>tuple[float, float]</code> <p>The value of the prolate spheroidal radial function and its' derivative.</p> Notes <p>This method uses the prolate spheroidal wave function code for non complex arguments (van Buren &amp; Boisvert, 2002, and van Buren &amp; Boisvert, 2024), available on github. This code is in Fortran90 and was interfaced to Python using <code>numpy.f2py</code> then wrapped with the current method to provide a similar calling convention as the Scipy function of the same name.</p> References <p>Van Buren, A. L., &amp; Boisvert, J. E. (2002). Accurate calculation of prolate spheroidal radial functions of the first kind and their first derivatives. Quarterly of Applied Mathematics, 60(3), 589-599. https://doi.org/10.1090/qam/1914443</p> <p>Van Buren, A. L., &amp; Boisvert, J. E. (2004). Improved Calculation of Prolate Spheroidal Radial Functions of the Second Kind and Their First Derivatives. Quarterly of Applied Mathematics, 62(3), 493-507. https://doi.org/10.1090/qam/2086042</p> Source code in <code>src/echosms/utils.py</code> <pre><code>def pro_rad2(m: int, n: int, c: float, xi: float) -&gt; tuple[float, float]:\n    \"\"\"Prolate spheroidal radial function of the second kind and derivative.\n\n    Calculates the prolate spheroidal radial function of the second kind and its'\n    derivative with respect to `xi`.\n\n    Parameters\n    ----------\n    m :\n        The order parameter (\u2265 0).\n    n :\n        The degree parameter (\u2265 `m`).\n    c :\n        The size parameter.\n    xi :\n        The radial coordinate, \u03be, where \u03be \u2265 1.\n\n    Returns\n    -------\n    :\n        The value of the prolate spheroidal radial function and its' derivative.\n\n    Notes\n    -----\n    This method uses the prolate spheroidal wave function code for non complex\n    arguments (van Buren &amp; Boisvert, 2002, and van Buren &amp; Boisvert, 2024), available on\n    [github](https://github.com/MathieuandSpheroidalWaveFunctions). This code is in Fortran90\n    and was interfaced to Python using `numpy.f2py` then wrapped with the current method to\n    provide a similar calling convention as the Scipy function of the same name.\n\n    References\n    ----------\n    Van Buren, A. L., &amp; Boisvert, J. E. (2002). Accurate calculation of prolate spheroidal\n    radial functions of the first kind and their first derivatives. Quarterly of Applied\n    Mathematics, 60(3), 589-599. &lt;https://doi.org/10.1090/qam/1914443&gt;\n\n    Van Buren, A. L., &amp; Boisvert, J. E. (2004). Improved Calculation of Prolate Spheroidal\n    Radial Functions of the Second Kind and Their First Derivatives. Quarterly of Applied\n    Mathematics, 62(3), 493-507. &lt;https://doi.org/10.1090/qam/2086042&gt;\n    \"\"\"\n    if m &lt; 0:\n        raise ValueError('The m parameter must be positive.')\n    if n &lt; m:\n        raise ValueError('The n parameter must be greater than or equal to the m parameter.')\n    if xi &lt; 1.0:\n        raise ValueError('The xi parameter must be greater than or equal to 1')\n\n    ioprad = 1 if xi-1.0 &lt; 1e-10 else 2\n\n    # Add +2 to lnum instead of +1 as it exposes a bug in the Fortran code - if n = 0, zeros\n    # are returned instead of the correct value.\n    a = prolate_swf.profcn(c=c, m=m, lnum=n-m+2, x1=xi-1.0,\n                           ioprad=ioprad, iopang=0, iopnorm=0, arg=[0])\n    p = swf_t._make(a)\n\n    if ioprad == 1:\n        s = np.inf\n        sp = np.inf\n    else:\n        s = p.r2c * np.float_power(10.0, p.ir2e)\n        sp = p.r2dc * np.float_power(10.0, p.ir2de)\n\n    return s[n-m], sp[n-m]\n</code></pre>"},{"location":"api_reference/#echosms.shape_conversions","title":"<code>echosms.shape_conversions</code>","text":"<p>Functions that convert between different echoSMs datastore shape representations.</p>"},{"location":"api_reference/#echosms.shape_conversions.outline_to_surface","title":"<code>outline_to_surface(outline, num_pts=20)</code>","text":"<p>Convert an outline shape to a surface shape.</p> PARAMETER DESCRIPTION <code>outline</code> <p>An echoSMs outline shape.</p> <p> TYPE: <code>dict</code> </p> <code>num_pts</code> <p>The number of points to place on each cross-sectional ellipse.</p> <p> TYPE: <code>int</code> DEFAULT: <code>20</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>An echoSMs surface shape with shape metadata as per the input shape.</p> Notes <p>Each outline cross-sectional ellipse is represented by a polygon with num_pts vertices. Triangles are created that join the vertices on adjacent polygons. The two ends are meshed using an ear slicing algorithm (using the <code>mapbox_earcut</code> package, a Python binding to a C++ implementation of the algorithm).</p> Source code in <code>src/echosms/shape_conversions.py</code> <pre><code>def outline_to_surface(outline: dict, num_pts:int = 20) -&gt; dict:\n    \"\"\"Convert an outline shape to a surface shape.\n\n    Parameters\n    ----------\n    outline :\n        An echoSMs outline shape.\n    num_pts :\n        The number of points to place on each cross-sectional ellipse.\n\n    Returns\n    -------\n    :\n        An echoSMs surface shape with shape metadata as per the input shape.\n\n    Notes\n    -----\n    Each outline cross-sectional ellipse is represented by a polygon with num_pts\n    vertices. Triangles are created that join the vertices on adjacent polygons.\n    The two ends are meshed using an ear slicing algorithm (using the `mapbox_earcut` package, a\n    Python binding to a [C++ implementation](https://github.com/mapbox/earcut.hpp) of the\n    algorithm).\n    \"\"\"\n    num_discs = len(outline['x'])\n\n    # Create points around each ellipse cross-section of the outline shape\n    t = np.linspace(0, 2*np.pi, num=num_pts, endpoint=False)\n    pts = []\n    # Could vectorise this, but then the code is harder to understand and the number of\n    # discs that this will iterate over is fairly small so speed isn't a concern\n    for i in range(num_discs):\n        pts_y = outline['y'][i] + outline['width'][i]/2 * np.cos(t)\n        pts_z = outline['z'][i] + outline['height'][i]/2 * np.sin(t)\n        pts_x = np.full(pts_y.shape, outline['x'][i])\n        pts.extend(np.c_[pts_x, pts_y, pts_z].tolist())\n\n    # Create triangles connecting respective points on each ellipse\n    # Same vectorisation comment here as above\n    faces = []\n    for disc in range(num_discs-1):\n        for pt_i in range(num_pts):\n            face = [disc*num_pts + pt_i,\n                    (disc+1)*num_pts + pt_i,\n                    disc*num_pts + (pt_i+1) % num_pts]\n            faces.append(face)\n\n            face = [disc*num_pts + (pt_i+1) % num_pts,\n                    (disc+1)*num_pts + pt_i,\n                    (disc+1)*num_pts + (pt_i+1) % num_pts]\n            faces.append(face)\n\n    # Create triangles for the two end surfaces\n    # TODO - ensure this works for end surfaces that are a point (e.g. width or height = 0)\n    pts2d = [[p[1], p[2]] for p in pts]  # shapely.Polygon wants a 2D polygon, so remove the x coord\n\n    _, endcap1_faces = triangulate_polygon(Polygon(pts2d[:num_pts]), engine='earcut')\n    # the order of the nodes is inverted for endcap2 to have the normals point outwards\n    _, endcap2_faces = triangulate_polygon(Polygon(pts2d[:-(num_pts+1):-1]), engine='earcut')\n    # Get the right facet indices for endcap2\n    endcap2_faces = [f - 1 + num_pts * (num_discs-1) for f in endcap2_faces]\n\n    faces.extend(endcap1_faces)\n    faces.extend(endcap2_faces)\n\n    # Put into trimesh to get the face normals\n    mesh = Trimesh(vertices=pts, faces=faces)\n\n    if not mesh.is_volume:\n        raise ValueError('Mesh is not watertight, not wound consistently, '\n                         'or normals are not facing outwards')\n\n    # TODO - consider resampling the mesh to give triangles all of a similar size\n\n    # structure as an echoSMs surface dict\n    surface = {'x': mesh.vertices[:, 0].tolist(),\n               'y': mesh.vertices[:, 1].tolist(),\n               'z': mesh.vertices[:, 2].tolist(),\n               'facets_0': mesh.faces[:, 0].tolist(),\n               'facets_1': mesh.faces[:, 1].tolist(),\n               'facets_2': mesh.faces[:, 2].tolist(),\n               'normals_x': mesh.face_normals[:, 0].tolist(),\n               'normals_y': mesh.face_normals[:, 1].tolist(),\n               'normals_z': mesh.face_normals[:, 2].tolist(),\n               }\n\n    # Copy across other attributes from the outline shape\n    attrs = {k:v for k, v in outline.items() if k not in ['x', 'y', 'z', 'height', 'width']}\n\n    return attrs | surface\n</code></pre>"},{"location":"api_reference/#echosms.shape_conversions.surface_to_outline","title":"<code>surface_to_outline(shape, slice_thickness=0.005)</code>","text":"<p>Convert a surface shape to an outline shape.</p> PARAMETER DESCRIPTION <code>shape</code> <p>An echoSMs surface shape.</p> <p> TYPE: <code>dict</code> </p> <code>slice_thickness</code> <p>The slice thickness [m] used when generating the outline.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.005</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>An echoSMs outline shape with shape metadata as per the input shape.</p> Notes <p>The conversion projects the surface shape to get dorsal and lateral outlines and then slices along the x-axis at a configurable resolution to produce the outline shape.</p> Source code in <code>src/echosms/shape_conversions.py</code> <pre><code>def surface_to_outline(shape: dict, slice_thickness: float=5e-3) -&gt; dict:\n    \"\"\"Convert a surface shape to an outline shape.\n\n    Parameters\n    ----------\n    shape :\n        An echoSMs surface shape.\n    slice_thickness :\n        The slice thickness [m] used when generating the outline.\n\n    Returns\n    -------\n    :\n        An echoSMs outline shape with shape metadata as per the input shape.\n\n    Notes\n    -----\n    The conversion projects the surface shape to get dorsal and lateral outlines and then\n    slices along the _x_-axis at a configurable resolution to produce the outline shape.\n    \"\"\"\n    # Put the shape into a trimesh mesh\n    v = np.array([shape['x'], shape['y'], shape['z']]).T\n    f = np.array([shape['facets_0'], shape['facets_1'], shape['facets_2']]).T\n    mesh = trimesh.Trimesh(vertices=v, faces=f)\n\n    # Project the surface mesh onto dorsal and lateral planes\n    dorsal = projected(mesh, normal=[0, 0, 1], ignore_sign=True)\n    lateral = projected(mesh, normal=[0, -1, 0], ignore_sign=True)\n\n    # Get bounds for a centreline on the x-axis that extends the full length of the organism\n    bounds = mesh.bounding_box\n    xmin = bounds.vertices[0, 0]\n    xmax = bounds.vertices[7, 0]\n\n    # calculate the shape heights, widths, and y and z coordinates of the centreline\n    widths = []\n    heights = []\n    centreline_x = []\n    centreline_y = []\n    centreline_z = []\n\n    for x in np.arange(xmin, xmax, slice_thickness):\n        # Get the points where a line perpendicular to the x-axis intersects\n        # the dorsal and lateral shapes\n\n        # A line perpendicular to the x-axis that extends off a long way (1000 m)\n        line = LineString([[x, -1000], [x, 1000]])\n        # and the intersection of that line with the dorsal shape\n        intersect = intersection(dorsal, line)\n\n        # If there is no intersection, go to the next x-point. This can happen\n        # at the start or end of the bounding box\n        if not intersect:\n            continue\n\n        # The length of that line is the width of the shape at this x position\n        w = intersect.length\n        # and the centre point of that line is the y coordinate of the centreline\n        centre = intersect.interpolate(0.5, normalized=True)\n        y = -centre.y\n\n        # Do similar for the lateral outline\n        line = LineString([[-1000, x], [1000, x]])\n        intersect = intersection(lateral, line)\n        if not intersect:\n            continue\n\n        heights.append(intersect.length)\n        centre = intersect.interpolate(0.5, normalized=True)\n\n        widths.append(w)\n        centreline_x.append(x)\n        centreline_y.append(y)\n        centreline_z.append(centre.x)\n\n    # Create an echoSMs shape dict using the metadata from the input surface shape\n    to_remove = ['x', 'y', 'z', 'facets_0', 'facets_1', 'facets_2',\n                 'normals_x', 'normals_y', 'normals_z']\n    outline_shape = {k: v for k, v in shape.items() if k not in to_remove}\n\n    # Add the outline shape data\n    outline_shape['x'] = centreline_x\n    outline_shape['y'] = centreline_y\n    outline_shape['z'] = centreline_z\n    outline_shape['height'] = heights\n    outline_shape['width'] = widths\n\n    return outline_shape\n</code></pre>"},{"location":"api_reference/#anatomical-datastore","title":"Anatomical datastore","text":""},{"location":"api_reference/#echosms.utils_datastore","title":"<code>echosms.utils_datastore</code>","text":"<p>Utilities for working with the echoSMs anatomical datastore.</p>"},{"location":"api_reference/#echosms.utils_datastore.dwbaorganism_from_datastore","title":"<code>dwbaorganism_from_datastore(shape)</code>","text":"<p>Create a DWBAorganism instance from an echoSMs datastore shape.</p> <p>Converts the centreline and width/height definition of a shape into that required by the echoSMs implementation of the DWBA (centreline, tangential, and radii vectors).</p> PARAMETER DESCRIPTION <code>shape</code> <p>The shape to convert, in the echoSMs datastore <code>outline</code> shape data structure.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>    An instance of DWBAorganism</code> Notes <p>The DWBA simulates a circular shape but the echoSMs datastore shape can store non- circular shapes (via the height and width). This function uses the height information and ignores the width information.</p> <p>If <code>mass_density_ratio</code> and <code>sound_speed_ratio</code> are present into the shape dict, these are used. If not, default values are used by DWBorganism().</p> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def dwbaorganism_from_datastore(shape: dict):\n    \"\"\"Create a DWBAorganism instance from an echoSMs datastore shape.\n\n    Converts the centreline and width/height definition of a shape into that\n    required by the echoSMs implementation of the DWBA (centreline, tangential, and\n    radii vectors).\n\n    Parameters\n    ----------\n    shape :\n        The shape to convert, in the echoSMs datastore `outline` shape data structure.\n\n    Returns\n    -------\n        An instance of DWBAorganism\n\n    Notes\n    -----\n    The DWBA simulates a circular shape but the echoSMs datastore shape can store non-\n    circular shapes (via the height and width). This function uses the height information\n    and ignores the width information.\n\n    If `mass_density_ratio` and `sound_speed_ratio` are present into the shape dict,\n    these are used. If not, default values are used by DWBorganism().\n    \"\"\"\n    from echosms import create_dwba_from_xyza  # here to avoid a circular import\n    a = np.array(shape['height']) * 0.5\n    if 'mass_density_ratio' in shape and 'sound_speed_ratio' in shape:\n        return create_dwba_from_xyza(shape['x'], shape['y'], shape['z'], a,\n                                     shape['name'], shape['mass_density_ratio'],\n                                     shape['sound_speed_ratio'])\n\n    return create_dwba_from_xyza(shape['x'], shape['y'], shape['z'], a, shape['name'])\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.krmorganism_from_datastore","title":"<code>krmorganism_from_datastore(shapes)</code>","text":"<p>Create a KRMorganism instance from an echoSMs datastore shape.</p> <p>Converts the centreline and width/height definition of a shape into that required by the echoSMs implementation of the KRM (straight centreline, width, upper and lower heights from the centreline).</p> PARAMETER DESCRIPTION <code>shapes</code> <p>The shapes to convert, in the echoSMs datastore <code>outline</code> shape data structure.</p> <p> TYPE: <code>list[dict]</code> </p> RETURNS DESCRIPTION <code>    Instances of KRMorganism</code> Notes <p>The shape with name <code>body</code> becomes the main organism body and all other shapes become inclusions. If there is no shape with name of <code>body</code>, the first shape is used for the body.</p> <p>The KRM uses just one sound speed and density per shape, but datastore shapes can have values per x-axis value. The mean of the sound speed and density values are used if so.</p> <p>Datastore shapes can have non-zero y-axis values but these are ignored when creating a KRMorganism instance.</p> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def krmorganism_from_datastore(shapes: list[dict]) -&gt; list:\n    \"\"\"Create a KRMorganism instance from an echoSMs datastore shape.\n\n    Converts the centreline and width/height definition of a shape into that\n    required by the echoSMs implementation of the KRM (straight centreline, width, upper and\n    lower heights from the centreline).\n\n    Parameters\n    ----------\n    shapes :\n        The shapes to convert, in the echoSMs datastore `outline` shape data structure.\n\n    Returns\n    -------\n        Instances of KRMorganism\n\n    Notes\n    -----\n    The shape with name `body` becomes the main organism body and all other shapes become\n    inclusions. If there is no shape with name of `body`, the first shape is used for the body.\n\n    The KRM uses just one sound speed and density per shape, but datastore shapes can have values\n    per _x_-axis value. The mean of the sound speed and density values are used if so.\n\n    Datastore shapes can have non-zero _y_-axis values but these are ignored when creating\n    a KRMorganism instance.\n\n    \"\"\"\n    from echosms import KRMorganism, KRMshape  # here to avoid a circular import\n\n    def _to_KRMshape(s: dict):\n        \"\"\"Convert echoSMs datstore shape into a KRMshape.\"\"\"\n        # Take mean of sound speed and density in case there is more than one value.\n        c = sum(s['sound_speed_compressional'])/len(s['sound_speed_compressional'])\n        rho = sum(s['mass_density'])/len(s['mass_density'])\n\n        height2 = np.array(s['height'])/2.0\n        return KRMshape(s['boundary'], np.array(s['x']), np.array(s['width']),\n                        s['z'] + height2, s['z'] - height2, c, rho)\n\n    if len(shapes) == 0:\n        return KRMorganism('', '', [], [])\n\n    KRMshapes = [_to_KRMshape(s) for s in shapes]\n\n    # get the index of the first shape with name == 'body' (if any)\n    idx = [i for i, s in enumerate(shapes) if s['anatomical_feature'] == 'body']\n    if not idx:\n        idx = [0]  # No shape with name of body so we use the first shape as the body\n\n    body = KRMshapes.pop(idx[0])\n    inclusions = KRMshapes\n\n    return KRMorganism('', '', body, inclusions)\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.mesh_from_datastore","title":"<code>mesh_from_datastore(shapes)</code>","text":"<p>Create trimesh instances from an echoSMs datastore surface shape.</p> PARAMETER DESCRIPTION <code>shapes</code> <p>The shapes to convert, in the echoSMs datastore <code>surface</code> shape data structure.</p> <p> TYPE: <code>list[dict]</code> </p> RETURNS DESCRIPTION <code>    The shapes in trimesh form, in the same order as the input.</code> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def mesh_from_datastore(shapes: list[dict]) -&gt; list[trimesh]:\n    \"\"\"Create trimesh instances from an echoSMs datastore surface shape.\n\n    Parameters\n    ----------\n    shapes :\n        The shapes to convert, in the echoSMs datastore `surface` shape data structure.\n\n    Returns\n    -------\n        The shapes in trimesh form, in the same order as the input.\n\n    \"\"\"\n\n    def _to_trimesh(s: dict) -&gt; trimesh.Trimesh:\n        \"\"\"Put echoSMs datstore shape into a trimesh instance.\"\"\"\n        faces = [f for f in zip(s['facets_0'], s['facets_1'], s['facets_2'])]\n        vertices = [v for v in zip(s['x'], s['y'], s['z'])]\n\n        return trimesh.Trimesh(vertices=vertices, faces=faces, process=False)\n\n    return [_to_trimesh(s) for s in shapes]\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.outline_from_dwba","title":"<code>outline_from_dwba(x, z, radius, anatomical_feature='body', boundary='pressure-release')</code>","text":"<p>Convert DWBA shape to the echoSMs outline shape representation.</p> PARAMETER DESCRIPTION <code>x</code> <p>The x values of the centreline</p> <p> </p> <code>z</code> <p>The distance of the centreline from z = 0. Positive values are towards the dorsal surface and negative values towards the ventral surface.</p> <p> </p> <code>radius</code> <p>The radius of the shape at each x coordinate</p> <p> </p> <code>anatomical_feature</code> <p>The anatomical feature for this shape, as per the echoSMs datastore schema.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'body'</code> </p> <code>boundary</code> <p>The boundary type for this shape, as per the echoSMs datastore schema.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pressure-release'</code> </p> RETURNS DESCRIPTION <code> An echoSMs outline shape representation.</code> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def outline_from_dwba(x, z, radius, anatomical_feature: str = \"body\",\n                      boundary: str = 'pressure-release') -&gt; dict:\n    \"\"\"\n    Convert DWBA shape to the echoSMs outline shape representation.\n\n    Parameters\n    ----------\n    x :\n        The _x_ values of the centreline\n    z :\n        The distance of the centreline from _z_ = 0. Positive values are towards\n        the dorsal surface and negative values towards the ventral surface.\n    radius :\n        The radius of the shape at each _x_ coordinate\n    anatomical_feature :\n        The anatomical feature for this shape, as per the echoSMs datastore schema.\n    boundary :\n        The boundary type for this shape, as per the echoSMs datastore schema.\n\n    Returns\n    -------\n     An echoSMs outline shape representation.\n\n    \"\"\"\n    return {'anatomical_feature': anatomical_feature,\n            'boundary': boundary,\n            'shape_units': 'm',\n            'x': np.array(x).tolist(),\n            'y': np.zeros(len(x)).tolist(),\n            'z': (-np.array(z)).tolist(),\n            'height': (2*np.array(radius)).tolist(),\n            'width': (2*np.array(radius)).tolist()}\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.outline_from_krm","title":"<code>outline_from_krm(x, height_u, height_l, width, anatomical_feature='body', boundary='pressure-release')</code>","text":"<p>Convert KRM shape representation to the echoSMs outline shape representation.</p> PARAMETER DESCRIPTION <code>x</code> <p>The x values of the centreline</p> <p> TYPE: <code>ArrayLike</code> </p> <code>height_u</code> <p>The distance from z = 0 to the upper part of the shape at each x coordinate. Positive values are towards the dorsal surface and negative values towards the ventral surface.</p> <p> TYPE: <code>ArrayLike</code> </p> <code>height_l</code> <p>The distance from z = 0 to the lower part of the shape at each x coordinate. Positive values are towards the dorsal surface and negative values towards the ventral surface.</p> <p> TYPE: <code>ArrayLike</code> </p> <code>width</code> <p>The width of the shape at each x coordinate</p> <p> TYPE: <code>ArrayLike</code> </p> <code>anatomical_feature</code> <p>The anatomical feature for this shape, as per the echoSMs datastore schema.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'body'</code> </p> <code>boundary</code> <p>The boundary type for this shape, as per the echoSMs datastore schema.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pressure-release'</code> </p> RETURNS DESCRIPTION <code> An echoSMs outline shape representation.</code> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def outline_from_krm(x: npt.ArrayLike, height_u: npt.ArrayLike, height_l: npt.ArrayLike,\n                     width: npt.ArrayLike,\n                     anatomical_feature: str = \"body\",\n                     boundary: str = 'pressure-release') -&gt; dict:\n    \"\"\"\n    Convert KRM shape representation to the echoSMs outline shape representation.\n\n    Parameters\n    ----------\n    x :\n        The _x_ values of the centreline\n    height_u :\n        The distance from _z_ = 0 to the upper part of the shape at each _x_ coordinate.\n        Positive values are towards the dorsal surface and negative values towards the ventral\n        surface.\n    height_l :\n        The distance from _z_ = 0 to the lower part of the shape at each _x_ coordinate.\n        Positive values are towards the dorsal surface and negative values towards the ventral\n        surface.\n    width :\n        The width of the shape at each _x_ coordinate\n    anatomical_feature :\n        The anatomical feature for this shape, as per the echoSMs datastore schema.\n    boundary :\n        The boundary type for this shape, as per the echoSMs datastore schema.\n\n    Returns\n    -------\n     An echoSMs outline shape representation.\n    \"\"\"\n    y = np.zeros(len(x))\n    height = np.array(height_u) - np.array(height_l)\n    z = -(np.array(height_l) + height / 2.0)\n\n    return {'anatomical_feature': anatomical_feature, 'boundary': boundary,\n            'shape_units': 'm',\n            'x': np.array(x).tolist(),\n            'y': y.tolist(),\n            'z': z.tolist(),\n            'height': height.tolist(),\n            'width': np.array(width).tolist()}\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.plot_shape_categorised_voxels","title":"<code>plot_shape_categorised_voxels(s, title='')</code>","text":"<p>Plot the specimen's categorised voxels.</p> <p>Normally called via plot_specimen().</p> PARAMETER DESCRIPTION <code>s</code> <p>The categorised voxel shape data structure as per the echoSMs datastore.</p> <p> </p> <code>title</code> <p>Title for the plot.</p> <p> DEFAULT: <code>''</code> </p> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def plot_shape_categorised_voxels(s, title=''):\n    \"\"\"Plot the specimen's categorised voxels.\n\n    Normally called via [plot_specimen()][echosms.utils_datastore.plot_specimen].\n\n    Parameters\n    ----------\n    s :\n        The categorised voxel shape data structure as per the echoSMs datastore.\n    title :\n        Title for the plot.\n    \"\"\"\n    d = np.array(s['categories'])\n    voxel_size = np.array(s['voxel_size'])\n    shape = d.shape\n\n    cats = np.unique(d)\n    norm = colors.Normalize(vmin=min(cats), vmax=max(cats))\n\n    row_dim = np.linspace(0, voxel_size[0]*1e3*shape[0], shape[0]+1)\n    slice_dim = np.linspace(0, voxel_size[2]*1e3*shape[2], shape[2]+1)\n\n    cmap = colormaps['Dark2']\n\n    # Create 25 plots along the organism's echoSMs x-axis\n    fig, axs = plt.subplots(5, 5, sharex=True, sharey=True)\n    cols = np.linspace(0, shape[1]-1, num=25)\n\n    for col, ax in zip(cols, axs.flat):\n        c = int(floor(col))\n        # The [::-1] and .invert_ axis calls give the appropriate\n        # x and y axes directions in the plots.\n        ax.pcolormesh(slice_dim[::-1], row_dim[::-1], d[:,c,:],\n                      norm=norm, cmap=cmap)\n\n        ax.set_aspect('equal')\n        ax.invert_xaxis()\n        ax.invert_yaxis()\n\n        ax.text(0.05, .86, f'{col*1e3*voxel_size[1]:.0f} mm',\n                transform=ax.transAxes, fontsize=6, color='white')\n\n    fig.supxlabel('y [mm]')\n    fig.supylabel('z [mm]')\n    fig.suptitle(title)\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.plot_shape_outline","title":"<code>plot_shape_outline(shapes, axs)</code>","text":"<p>Plot an echoSMs anatomical outline shape.</p> <p>Normally called via plot_specimen().</p> PARAMETER DESCRIPTION <code>shapes</code> <p>Outline shapes to be plotted</p> <p> TYPE: <code>list[dict]</code> </p> <code>axs</code> <p>Two matplotlib axes - one for the dorsal view and one for the lateral view</p> <p> TYPE: <code>list</code> </p> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def plot_shape_outline(shapes: list[dict], axs: list) -&gt; None:\n    \"\"\"Plot an echoSMs anatomical outline shape.\n\n    Normally called via [plot_specimen()][echosms.utils_datastore.plot_specimen].\n\n    Parameters\n    ----------\n    shapes :\n        Outline shapes to be plotted\n    axs :\n        Two matplotlib axes - one for the dorsal view and one for the\n        lateral view\n    \"\"\"\n    for s in shapes:\n        c = 'C0' if s['boundary'] == bt.fluid_filled else 'C1'\n        x = np.array(s['x'])*1e3\n        z = np.array(s['z'])*1e3\n        y = np.array(s['y'])*1e3\n        width_2 = np.array(s['width'])/2*1e3\n        zU = (z + np.array(s['height'])/2*1e3)\n        zL = (z - np.array(s['height'])/2*1e3)\n\n        # Dorsal view\n        axs[0].plot(x, y, c='grey', linestyle='--', linewidth=1)  # centreline\n        axs[0].plot(x, y+width_2, c=c)\n        axs[0].plot(x, y-width_2, c=c)\n\n        # Lateral view\n        axs[1].plot(x, z, c='grey', linestyle='--', linewidth=1)  # centreline\n        axs[1].plot(x, zU, c=c)\n        axs[1].plot(x, zL, c=c)\n\n        # close the ends of the shapes\n        for i in [0, -1]:\n            axs[1].plot([x[i], x[i]], [zU[i], zL[i]], c=c)\n            axs[0].plot([x[i], x[i]], [(y+width_2)[i], (y-width_2)[i]], c=c)\n            axs[i].xaxis.set_inverted(True)\n            axs[i].yaxis.set_inverted(True)\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.plot_shape_surface","title":"<code>plot_shape_surface(shapes, ax)</code>","text":"<p>Plot an echoSMs anatomical surface shape.</p> <p>Normally called via plot_specimen().</p> PARAMETER DESCRIPTION <code>shapes</code> <p>Surface shapes to be plotted</p> <p> </p> <code>ax</code> <p>A matplotlib axis.</p> <p> </p> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def plot_shape_surface(shapes, ax):\n    \"\"\"Plot an echoSMs anatomical surface shape.\n\n    Normally called via [plot_specimen()][echosms.utils_datastore.plot_specimen].\n\n    Parameters\n    ----------\n    shapes :\n        Surface shapes to be plotted\n    ax :\n        A matplotlib axis.\n    \"\"\"\n    for s in shapes:\n        c = 'C0' if s['boundary'] == bt.fluid_filled else 'C1'\n        facets = np.array([s['facets_0'], s['facets_1'], s['facets_2']]).transpose()\n        x = 1e3 * np.array(s['x'])\n        y = 1e3 * np.array(s['y'])\n        z = 1e3 * np.array(s['z'])\n\n        ax.plot_trisurf(x, y, z, triangles=facets, alpha=0.6, color=c)\n        ax.view_init(elev=210, azim=-60, roll=0)\n        ax.set_xlabel('x')\n        ax.set_ylabel('y')\n        ax.set_zlabel('z')\n\n        ax.set_aspect('equal')\n        ax.xaxis.set_inverted(True)\n        ax.yaxis.set_inverted(True)\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.plot_shape_voxels","title":"<code>plot_shape_voxels(s, title='')</code>","text":"<p>Plot the specimen's voxels.</p> <p>Normally called via plot_specimen().</p> PARAMETER DESCRIPTION <code>s</code> <p>The voxel shape data structure as per the echoSMs datastore.</p> <p> </p> <code>title</code> <p>Title for the plot.</p> <p> DEFAULT: <code>''</code> </p> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def plot_shape_voxels(s, title=''):\n    \"\"\"Plot the specimen's voxels.\n\n    Normally called via [plot_specimen()][echosms.utils_datastore.plot_specimen].\n\n    Parameters\n    ----------\n    s :\n        The voxel shape data structure as per the echoSMs datastore.\n\n    title :\n        Title for the plot.\n\n    \"\"\"\n    # Show density. Could do sound speed or some impedance proxy.\n    d = np.array(s['sound_speed_compressional'])\n    voxel_size = np.array(s['voxel_size'])\n    shape = d.shape\n\n    # Make the colours ignore extreme high value and the lowest low values\n    norm = colors.Normalize(vmin=np.percentile(d.flat, 1),\n                            vmax=np.percentile(d.flat, 99))\n\n    row_dim = np.linspace(0, voxel_size[0]*1e3*shape[0], shape[0]+1)\n    slice_dim = np.linspace(0, voxel_size[2]*1e3*shape[2], shape[2]+1)\n\n    cmap = colormaps['viridis']\n\n    # Create 25 plots along the organism's echoSMs x-axis\n    fig, axs = plt.subplots(5, 5, sharex=True, sharey=True)\n    cols = np.linspace(0, shape[1]-1, num=25)\n\n    for col, ax in zip(cols, axs.flat):\n        c = int(floor(col))\n        # The [::-1] and .invert_ axis calls give the appropriate\n        # x and y axes directions in the plots.\n        im = ax.pcolormesh(slice_dim[::-1], row_dim[::-1], d[:,c,:],\n                           norm=norm, cmap=cmap)\n\n        ax.set_aspect('equal')\n        ax.invert_xaxis()\n        ax.invert_yaxis()\n\n        ax.text(0.05, .86, f'{col*1e3*voxel_size[1]:.0f} mm',\n                transform=ax.transAxes, fontsize=6, color='white')\n\n    # A single colorbar in the plot\n    cbar = fig.colorbar(im, ax=axs, orientation='vertical',\n                        fraction=0.1, extend='both', cmap=cmap)\n    cbar.ax.set_ylabel('[kg m$^{-3}$]')\n    fig.supxlabel('y [mm]')\n    fig.supylabel('z [mm]')\n    fig.suptitle(title)\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.plot_specimen","title":"<code>plot_specimen(specimen, dataset_label='', title='', savefile=None, dpi=150)</code>","text":"<p>Plot the specimen shape.</p> <p>Produces a relevant plot for all echoSMs anatomical datastore shape types.</p> PARAMETER DESCRIPTION <code>specimen</code> <p>Specimen data as per the echoSMs anatomical datastore schema.</p> <p> TYPE: <code>dict</code> </p> <code>dataset_label</code> <p>Used to form a plot title if <code>title</code> is an empty string.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>title</code> <p>A title for the plot.</p> <p> TYPE: <code>str</code> DEFAULT: <code>''</code> </p> <code>savefile</code> <p>Filename to save the plot to. If None, generate the plot in the interactive terminal (if that's supported).</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>dpi</code> <p>The resolution of the figure in dots per inch.</p> <p> TYPE: <code>float</code> DEFAULT: <code>150</code> </p> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def plot_specimen(specimen: dict, dataset_label: str='', title: str='',\n                  savefile: str|None=None, dpi: float=150) -&gt; None:\n    \"\"\"Plot the specimen shape.\n\n    Produces a relevant plot for all echoSMs anatomical datastore shape types.\n\n    Parameters\n    ----------\n    specimen :\n        Specimen data as per the echoSMs anatomical datastore schema.\n    dataset_label :\n        Used to form a plot title if `title` is an empty string.\n    title :\n        A title for the plot.\n    savefile :\n        Filename to save the plot to. If None, generate the plot in the\n        interactive terminal (if that's supported).\n    dpi :\n        The resolution of the figure in dots per inch.\n\n    \"\"\"\n    labels = ['Dorsal', 'Lateral']\n    t = title if title else dataset_label + ' ' + specimen['specimen_name']\n\n    match specimen['shape_type']:\n        case 'outline':\n            fig, axs = plt.subplots(2, 1, sharex=True, layout='tight')\n            fig.set_layout_engine('tight', h_pad=1, w_pad=1)\n            plot_shape_outline(specimen['shapes'], axs)\n            for label, a in zip(labels, axs):\n                a.set_title(label, loc='left', fontsize=8)\n                a.axis('scaled')\n            axs[0].set_title(t)\n            _fit_to_axes(fig)\n\n        case 'surface':\n            fig, ax = plt.subplots(subplot_kw={'projection': '3d'})\n            plot_shape_surface(specimen['shapes'], ax)\n            plt.tight_layout()\n            ax.set_title(t)\n        case 'voxels':\n            plot_shape_voxels(specimen['shapes'][0], t)\n        case 'categorised voxels':\n            plot_shape_categorised_voxels(specimen['shapes'][0], t)\n\n    if savefile:\n        plt.savefig(savefile, format='png', dpi=dpi, bbox_inches='tight')\n        plt.close()\n    else:\n        plt.show()\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.surface_from_stl","title":"<code>surface_from_stl(stl_file, dim_scale=1.0, anatomical_feature='body', boundary='pressure-release')</code>","text":"<p>Create an echoSMs surface shape from an .stl file.</p> PARAMETER DESCRIPTION <code>stl_file</code> <p>An .stl file</p> <p> TYPE: <code>str | Path</code> </p> <code>dim_scale</code> <p>Scaling factor applied to the node positions. Use to convert from one length unit to another (e.g., 1e-3 will convert from mm to m).</p> <p> TYPE: <code>float</code> DEFAULT: <code>1.0</code> </p> <code>anatomical_feature</code> <p>The anatomical feature for this shape, as per the echoSMs datastore schema.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'body'</code> </p> <code>boundary</code> <p>The boundary type for this shape, as per the echoSMs datastore schema.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pressure-release'</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>An echoSMs surface shape representation.</p> Notes <p>This function uses a call to <code>load_mesh()</code> from the <code>trimesh</code> library to read the .stl file. If there are problems with loading your .stl file, please refer to the <code>trimesh</code> documentation.</p> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def surface_from_stl(stl_file: str | Path,\n                     dim_scale: float = 1.0,\n                     anatomical_feature: str = 'body',\n                     boundary: str = 'pressure-release') -&gt; dict:\n    \"\"\"Create an echoSMs surface shape from an .stl file.\n\n    Parameters\n    ----------\n    stl_file :\n        An .stl file\n    dim_scale :\n        Scaling factor applied to the node positions. Use to convert from one\n        length unit to another (e.g., 1e-3 will convert from mm to m).\n    anatomical_feature :\n        The anatomical feature for this shape, as per the echoSMs datastore schema.\n    boundary :\n        The boundary type for this shape, as per the echoSMs datastore schema.\n\n    Returns\n    -------\n    :\n        An echoSMs surface shape representation.\n\n    Notes\n    -----\n    This function uses a call to `load_mesh()` from the `trimesh` library to read the\n    .stl file. If there are problems with loading your .stl file, please refer to the\n    `trimesh` documentation.\n    \"\"\"\n    mesh = trimesh.load_mesh(stl_file)\n\n    # Bundle up into a dict as per the echoSMs schema for a surface\n    return {'anatomical_feature': anatomical_feature, 'boundary': boundary,\n            'shape_units': 'm',\n            'x': (mesh.vertices[:, 0]*dim_scale).tolist(),\n            'y': (mesh.vertices[:, 1]*dim_scale).tolist(),\n            'z': (mesh.vertices[:, 2]*dim_scale).tolist(),\n            'facets_0': mesh.faces[:, 0].tolist(),\n            'facets_1': mesh.faces[:, 1].tolist(),\n            'facets_2': mesh.faces[:, 2].tolist(),\n            'normals_x': mesh.face_normals[:, 0].tolist(),\n            'normals_y': mesh.face_normals[:, 1].tolist(),\n            'normals_z': mesh.face_normals[:, 2].tolist()}\n</code></pre>"},{"location":"api_reference/#echosms.utils_datastore.volume_from_datastore","title":"<code>volume_from_datastore(voxels)</code>","text":"<p>Create a 3D numpy array from nested lists.</p> PARAMETER DESCRIPTION <code>voxels</code> <p>The datastore 3D voxel structure (list of list of list)</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>    A numpy 3D array.</code> Source code in <code>src/echosms/utils_datastore.py</code> <pre><code>def volume_from_datastore(voxels: list):\n    \"\"\"Create a 3D numpy array from nested lists.\n\n    Parameters\n    ----------\n    voxels :\n        The datastore 3D voxel structure (list of list of list)\n\n    Returns\n    -------\n        A numpy 3D array.\n    \"\"\"\n    return np.array(voxels)  # TODO - check ordering is correct!\n</code></pre>"},{"location":"benchmark_data/","title":"Benchmark Data","text":"<p>The benchmark data for the acoustic scattering models in Jech et al. (2015) are included in the echoSMs package. These comprise target strength values for two sets of benchmarks:</p> <ul> <li>Model runs over a range of frequencies</li> <li>Model runs over a range of incident angles at a frequency of 38 kHz</li> </ul> <p>These are provided as text files (see below), or as Pandas DataFrames via the [benchmarkdata] class.</p>"},{"location":"benchmark_data/#tsf","title":"TS(f)","text":"<p>This dataset contains target strength (TS re 1 m\u00b2 [dB]) as a function of acoustic frequency. The data file, Benchmark_Frequency_TS.csv, is formatted as comma-separated TS values given to a precision of two decimal places (i.e., 0.01 dB). The first row in the file contains column labels, indicating the model type for that column. NA represents TS values that were not computed.</p> <p>The column names and descriptions are:</p> Column Name Description Frequency_kHz Acoustic frequency in kHz. TS values are given at 2 kHz increments from 12 to 400 kHz. Sphere_Rigid Benchmark values for the rigid sphere. Sphere_PressureRelease Benchmark values for the pressure release sphere. Sphere_Gas Benchmark values for the gas filled sphere. Sphere_WeaklyScattering Benchmark values for the weakly scattering sphere. ShellSphere_PressureRelease Benchmark values for the pressure release shelled sphere. ShellSphere_Gas Benchmark values for the gas filled shelled sphere. ShellSphere_WeaklyScattering Benchmark values for the weakly scattering shelled sphere. ProlateSpheroid_Rigid Benchmark values for the rigid prolate spheroid. Valid TS values were computed for 12-80 kHz ProlateSpheroid_PressureRelease Benchmark values for the pressure release prolate spheroid. Valid TS values were computed for 12-80 kHz. ProlateSpheroid_Gas Benchmark values for the gas filled prolate spheroid. No benchmark TS values were computed. ProlateSpheroid_WeaklyScattering Benchmark values for the weakly scattering prolate spheroid. Cylinder_Rigid Benchmark values for the rigid cylinder. Cylinder_PressureRelease Benchmark values for the pressure release cylinder. Cylinder_Gas Benchmark values for the gas filled cylinder. Cylinder_WeaklyScattering Benchmark values for the weakly scattering cylinder."},{"location":"benchmark_data/#ts-at-38-khz","title":"TS(\u03b8) at 38 kHz","text":"<p>This dataset contains target strength (TS re 1m\u00b2 [dB]) as a function of insonifying angle of incidence (\u03b8) for the prolate spheroid and cylinder shapes. The data file Benchmark_Angle_TS.csv is formatted a comma-separated Ts values given to a precision of two decimal places (i.e., 0.01 dB). Incidence angle is as per the echoSMs convention. The first row in the file contains column labels, indicating the model type for that column. NA represents TS values that were not computed.</p> <p>The column names and descriptions are:</p> Column Name Description Angle_deg Angle of incidence. TS values are given at 2-degree increments from 0 to 90\u00b0. ProlateSpheroid_Rigid Benchmark values for the rigid prolate spheroid. ProlateSpheroid_PressureRelease Benchmark values for the pressure release prolate spheroid. ProlateSpheroid_Gas Benchmark values for the gas filled prolate spheroid. ProlateSpheroid_WeaklyScattering Benchmark values for the weakly scattering prolate spheroid. Cylinder_Rigid Benchmark values for the rigid cylinder. TS values for end-on (0\u00b0) incidence were not computed. Cylinder_PressureRelease Benchmark values for the pressure release cylinder. TS values for end-on (0\u00b0) incidence were not computed. Cylinder_Gas Benchmark values for the gas filled cylinder. TS values for end-on (0\u00b0) incidence were not computed. Cylinder_WeaklyScattering Benchmark values for the weakly scattering cylinder. TS values for end-on (0\u00b0) incidence were not computed."},{"location":"conventions/","title":"Conventions","text":""},{"location":"conventions/#units","title":"Units","text":"<p>We use SI units for the model parameters, except for angles (degrees instead of radians) and target strength (deciBels).  All model code must accept inputs and produce results using the units below. If the model calculations use different units internally, the code should internally convert between them.</p> Parameter Units Notes length, diameter, radius, thickness, etc m density kg/m\u00b3 sound speed m/s angle \u00b0 See Coordinate systems solid angle sr frequency Hz target strength dB reference value is 1 m\u00b2"},{"location":"conventions/#coordinate-systems","title":"Coordinate systems","text":"<p>The right-handed cartesian coordinate system as defined by ISO 80000-2<sup>1</sup> is to be used, as illustrated below. The acoustic wave is defined to always travel in the positive z direction and the organism is rotated to achieve different acoustic incidence angles.</p> <p>The Tait-Bryan z-y'-x'' (intrinsic) convention was chosen to represent organism rotations as it is commonly used in nautical situations. Intrinsic means that the rotations are about the axes of the rotating organism, rather than the original coordinate system. The order of rotations is z, then y, then x.</p> <p>Rotations about the z-axis are yaw (\u03c8), about the y-axis are pitch (\u03b8), and about the x-axis are roll (\u0278). The definitions are such that:</p> <ul> <li>A yaw (\u03c8) value of 0\u00b0 occurs when the organism lies along the positive x-axis (as per the illustration) and positive yaw values (as per the yellow arrow) rotate the organism's head towards the positive y-axis,</li> <li>Pitch (\u03b8) values of 0\u00b0, 90\u00b0, and 180\u00b0 correspond to acoustic wave incidence angles of head on, dorsal, and tail on, respectively,</li> <li>Roll (\u0278) values of \u201390\u00b0, 0\u00b0, and 90\u00b0 correspond to acoustic wave incidences onto the right (starboard), dorsal, and left (port) sides of the organism, respectively.</li> </ul> <p>All model code should accept angles and produce results in this coordinate system. If the model calculations use a different coordinate system, the code should internally convert between the system given above and the version used in the code.</p> <p> </p>"},{"location":"conventions/#coordinate-conversions","title":"Coordinate conversions","text":"<p>Some models use an incident wave vector instead of rotating the target. The appropriate vector for a given echoSMs yaw, pitch, and roll can be calculated using this Python code:</p> <pre><code>from scipy.spatial.transform import Rotation as R\nrot = R.from_euler('ZYX', (yaw, theta-90, -phi), degrees=True)  # angles in degrees\nincident_vector = rot.apply([0, 0, 1])\n</code></pre> <ol> <li> <p>ISO. 2019. ISO 80000-2. Part 2: Mathematics.\u00a0\u21a9</p> </li> </ol>"},{"location":"datastore_API/","title":"Web API","text":"Note <p>This page contains the draft API specification and documentation for web access to the echoSMs anatomical data store. It is a work in progress. The example data available from the web API may not always be consistent with the datastore schema.</p>"},{"location":"datastore_API/#introduction","title":"Introduction","text":"<p>The anatomical data store API is implemented as a REST web API with calls to:</p> <ol> <li>Query specimen metadata</li> <li>Obtain specimen information, definitions, and parameters.</li> <li>Access the full dataset associated with a specimen (this includes the raw data, processing scripts, intermediate data, etc).</li> </ol> <p>A testing server is available with some sample data, along with the API documentation. Example Python code that demonstrates use of the API is available here. That code also includes an example of how to download all specimen data to a local file for offline access.</p> <p>API endpoints to modify the data store have not yet been created as the data store can be manually loaded given the relatively low rate of expected model uploading.</p>"},{"location":"datastore_API/#example-api-calls","title":"Example API calls","text":"<p>Some example API calls are:</p> <ul> <li>A list of all specimens</li> <li>A list of all specimens in the CLAY_HORNE dataset</li> <li>A list of all specimens with a shape type of outline</li> <li>A list of all specimens with genus of Champsocephalus</li> <li>All data from the <code>B</code> specimen of the <code>CLAY_HORNE</code> dataset specimen and an image of that specimen</li> <li>A specimen with a shape type of voxels (and the metadata about that specimen)</li> <li>A specimen with a shape type of surface (and the metadata)</li> </ul> <p>The API call to get the full raw data is not yet implemented.</p>"},{"location":"datastore_API/#use-with-spreadsheets","title":"Use with spreadsheets","text":"<p>Microsoft Excel and Google Sheets can load data directly from the datastore API. For Excel navigate to the <code>Data</code> tab and choose <code>Get data-&gt;From Other Sources-&gt;From Web</code>, enter the specimens endpoint (<code>https://echosms-data-store-app-ogogm.ondigitalocean.app/v2/specimens</code>) and then use the Power Query Editor to select columns before loading into Excel. For Google Sheets use one of the many API/Data Connector add-ons (e.g. <code>API Connector</code>).</p>"},{"location":"datastore_anatomical/","title":"Anatomical data store","text":"Note <p>This page contains the draft specification and documentation for the echoSMs anatomical datastore. It is a work in progress. The specification here may not always be  consistent with the example data available from the web API.</p>"},{"location":"datastore_anatomical/#data-store-contents-and-structure","title":"Data store contents and structure","text":"<p>The datastore contains many datasets, where each dataset comprises the following:</p> <ol> <li>Metadata</li> <li>Input data to scattering models (material properties, 3D shapes, and other model parameters)</li> <li>Optionally, raw data files that were used to produce the scattering model input data (e.g., binary files, such as x-ray and photographic images, MRI &amp; CT scan files, etc)</li> <li>Optionally, processing files (programs, notes, intermediate data files, etc)</li> </ol> <p>Each dataset may contain information about more than one organism.</p> <p>The dataset metadata and model data have prescribed formats that are designed for convenient access via a REST API and for inputting to scattering models.</p> <p>The raw data and processing file formats and layout are unconstrained and are accessible via the REST API as a zipped download and a browsable directory hierarchy.</p> <p>Model outputs are not stored.</p>"},{"location":"datastore_anatomical/#preparing-datasets-for-the-datastore","title":"Preparing datasets for the datastore","text":"<p>A dataset ready for uploading to the datastore should contain the following files and directory structures, bundled into a single zip file:</p> Path File(s) Required Comment / metadata.toml no Metadata common to all specimens, in TOML format. The file name must be <code>metadata.toml</code> / specimen*.toml yes One file per specimen data. File names must start with <code>specimen</code> and have a suffix of <code>.toml</code>. If a <code>metadata.toml</code> files exists, the contents are appended to the specimen file. /data Any no Raw and processing files in user-supplied directory hierarchy <p>There is currently no automated way to upload datasets to the datastore - it is a manual process - raise an issue on Github or contact Gavin Macaulay to have datasets uploaded.</p>"},{"location":"datastore_anatomical/#data-formats","title":"Data formats","text":""},{"location":"datastore_anatomical/#raw-files","title":"Raw files","text":"<p>Raw data formats are not directly used by scattering models so do not need to be formatted for direct use in scattering models. Raw data typically includes images (e.g., png, tiff, jpg), imaging system files (e.g., CT, MRI, and x-ray \u2013 such as DICOM or sets of 2D images), and other more ad-hoc data (e.g., spreadsheets, csv files). Text-based file formats are preferred for their long-term usability, but well-defined and accessible binary formats are acceptable (e.g., common image formats and DICOM).</p>"},{"location":"datastore_anatomical/#processing-files","title":"Processing files","text":"<p>A preference for text file formats, then common binary formats (e.g, for images), then other binary formats with documentation. The aim here is to make the information readily accessible in the future without the use of specialised software.</p>"},{"location":"datastore_anatomical/#dataset-and-model-data","title":"Dataset and model data","text":"<p>The dataset metadata includes information about the species, the collection and processing of specimens used in scattering models, links to published work, and other context. These are intended to provide information for users to assess the quality, usability, and suitability of a particular dataset.</p> <p>Associated with each dataset are data about one or more specimens. This includes basic information about the specimen(s) (e.g., length and weight), along with the three-dimensional shape information required by acoustic scattering models. Note that a specimen is not necessarily a whole organism - the data structure allows for a specimen to be some part of the organism (e.g., swimbladder, organs, etc)</p> <p>The dataset contents are specified by a JSON schema file stored in the echoSMs github repository. The schema documents the required attributes, their structure, valid values, etc. The schema is a very technical document and is perhaps more easily understood via the table in the echoSMs documentation and an example file.</p> <p>Your dataset files can be validated against the datastore schema using online validators (e.g., here, here, or here), or within your own code using a JSON schema validation library (e.g., jsonschema-rs for Python and jsonvalidate for R). It is not necessary to validate your data before submitting it to the datastore, but it will help the uploading happen faster (a validation is done during the uploading process and any dataset format problems will be identified then).</p>"},{"location":"datastore_anatomical/#units","title":"Units","text":"<p>All physical numerical values in a dataset must be provided in the SI units prescribed in the datastore schema. If shape data contains values with different units, they must be converted to the prescribed units for the .toml files. The main situation where this occurs are the shape coordinate units - the datastore requires metres, but the original shape data are often in millimetres, centimetres, inches, etc.</p> <p>Forcing particular units places the burden of unit conversion on the data provider. The alternative (accepting any unit) requires data users to convert units to suit their model software. This is likely to generate more errors and require more effort than the data provider doing the conversion.</p>"},{"location":"datastore_anatomical/#shapes","title":"Shapes","text":"<p>Most anatomical scattering models use one of these three-dimensional representations:</p> <ul> <li>3D triangulated surface meshes,</li> <li>dorsal and ventral outlines,</li> <li>3D grids of cuboids (voxels).</li> </ul> <p>Some models use multiple shapes for a single specimen (e.g., a fish body and swimbladder) and multiple shapes per specimen are permitted. Additional shape formats can be added as required (e.g., tetrahedrons as used by the TetraScatt scattering model).</p> Shape data type Realisation Models that use this Example from datastore Material properties surface 3D triangular surface mesh BEM, KA data, image \u03c1 and c per shape outline Dorsal and ventral outlines along a curved centreline KRM, DWBA, DCM data, image \u03c1 and c per shape (KRM) or per section (DWBA) voxels 3D rectangular grid FEM data, image \u03c1 and c for each voxel categorised voxels categorised 3D rectangular grid PT-DWBA data, image \u03c1 and c for each category Note <p>The outline shape is a generalised form of the shape definition used for several models:</p> <ul> <li>KRM: non-circular cross-sections along a straight centreline</li> <li>DWBA: circular cross-sections along a curved centreline</li> <li>DCM: circular cross-sections along a straight or curved centreline</li> </ul>"},{"location":"datastore_anatomical/#shape-data-structure","title":"Shape data structure","text":"<p>The shape data format is formally specified in the echoSMs anatomical data store schema, but some additional explanatory notes, utility code, and examples are provided here.</p>"},{"location":"datastore_anatomical/#surface","title":"Surface","text":"<p>The <code>surface</code> format contains a 3D triangular surface mesh. The mesh is represented with three numeric arrays (<code>x</code>, <code>y</code>, and <code>z</code>) for the x, y, and z coordinates of the surface nodes, three integer arrays (<code>facets_0</code>, <code>facets_1</code>, <code>facets_2</code>) that index into the x, y, and z arrays and specify the nodes that make up individual triangles, and three arrays that give the outward unit normal vector for each triangle (<code>normals_x</code>, <code>normals_y</code>, and <code>normals_z</code>). The lengths of the facets and normals arrays must all be the same.</p> Note <p>Some scattering models require a closed 3D surface mesh (i.e., without holes), but the <code>surface</code> format does not enforce this.</p> <p>EchoSMs provides a function, surface_from_stl(), to convert an STL file into the echoSMs surface shape format:</p> <pre><code>from echosms import surface_from_stl\n\nshape = surface_from_stl('A.stl', dim_scale=1e-3, anatomical_feature='swimbladder',\n                          boundary='pressure-release')\n</code></pre> <p>This shape can then be combined with specimen metadata and written to a TOML file ready for loading into the echoSMs datastore:</p> <pre><code>import tomli_w\nimport uuid\nfrom datetime import datetime, timezone\n\n# Create specimen metadata and add in the shape\n# The items here are the mandatory attributes required for the \n# echoSMs datastore (there are many others that are optional).\nspecimen = {'uuid': str(uuid.uuid4()),\n            'specimen_name': 'A',\n            'version_number': 1,\n            'version_time': datetime.now(timezone.utc).isoformat(),\n            'version_note': 'Initial version',\n            'description': ['Testing'],\n            'anatomical_category': 'organism',\n            'aphia_id': 1234,\n            'date_collection': 'unknown',\n            'date_image': 'unknown',\n            'imaging_method': 'radiograph',\n            'shape_method': 'unknown',\n            'straightened': True,\n            'smoothed': False,\n            'rotated': False,\n            'dataset_size': 1.0,\n            'dataset_units': 'megabyte',\n            'specimen_condition': 'unknown',\n            'length': 0.0,\n            'length_units': 'm',\n            'length_type': 'unknown',\n            'shape_type': 'surface',\n            'shapes': [shape]}\n\n# Write to a TOML file\nwith open('specimen_A.toml', 'wb') as f:\n    tomli_w.dump(specimen, f)\n</code></pre> <p>There is a complimentary function to <code>surface_from_stl()</code> that takes the echoSMs datastore surface format and returns a trimesh object (see mesh_from_datastore()), from which an STL file can be written.</p>"},{"location":"datastore_anatomical/#outline","title":"Outline","text":"<p>The <code>outline</code> format is a generalised structure that can represent the outline shapes typically used for the DWBA, KRM, and DCM models. It uses a centreline (defined by a list of (x, y, z) coordinates) and a height and width at each centreline point. The echoSMs coordinate system is used so heights are along the z-axis and widths along the y-axis. Five numeric arrays are used to represent the shape in the echSMs format with names of <code>x</code>, <code>y</code>, <code>z</code>, <code>height</code>, and <code>width</code>. The lengths of these arrays must all be the same.</p> <p>EchoSMs provides functions to convert to and from the outline format into the specific formats typically required by the DWBA, KRM, and DCM models - see the examples below.</p> <p>Historically, outline shapes used in the KRM model used a centreline coincident with the x-axis (i.e., y = z = 0), upper and lower shape distances measured from the centreline, and symmetric widths. This form of outline shape can be converted to the datastore form using an echoSMs utility function:</p> <pre><code>from echosms import outline_from_krm, KRMdata, plot_specimen\nimport uuid\nfrom datetime import datetime, timezone\n\n# Get a fish shape from the old echoSMs KRM datastore\ndata = KRMdata()\ncod = data.model('Cod')\ncod.plot()\n\n# Convert the shape to the echoSMs anatomical datastore form. To keep\n# this example brief, only do the body outline and ignore any inclusions.\ns = outline_from_krm(x = cod.body.x,\n                     height_u = cod.body.z_U,\n                     height_l = cod.body.z_L,\n                     width = cod.body.w,\n                     anatomical_feature ='body',\n                     boundary=str(cod.body.boundary))\n\n# Add in other shape attributes to give a shape that contains all\n# those required by the schema.\ns['sound_speed_compressional'] = cod.body.rho\ns['sound_speed_compressional_units'] = 'm/s'\ns['mass_density'] = cod.body.c\ns['mass_density_units'] = 'kg/m^3'\n\n# The shape is now in the echoSMs anatomical datastore form with\n# (x,y,z) points defining the centreline and widths and heights for\n# the body size.\nprint(s.keys())\n\n# Add the shape to some example specimen metadata\nspecimen = {'uuid': str(uuid.uuid4()),\n            'specimen_name': 'A',\n            'version_number': 1,\n            'version_time': datetime.now(timezone.utc).isoformat(),\n            'version_note': 'Initial version',\n            'description': ['Testing'],\n            'anatomical_category': 'organism',\n            'aphia_id': 1234,\n            'date_collection': 'unknown',\n            'date_image': 'unknown',\n            'imaging_method': 'radiograph',\n            'shape_method': 'unknown',\n            'straightened': True,\n            'smoothed': False,\n            'rotated': False,\n            'dataset_size': 1.0,\n            'dataset_units': 'megabyte',\n            'specimen_condition': 'unknown',\n            'length': 0.0,\n            'length_units': 'm',\n            'length_type': 'unknown',\n            'shape_type': 'outline',\n            'shapes': [s]}\n\n# And use an echoSMs function to plot the shape \n# (to compare to the one from KRMdata above()).\nplot_specimen(specimen)\n</code></pre> <p>In the same way as for the surface mesh example above, the  specimen data can be written to a TOML file.</p> <p>DBWA model implementations tend to use a centreline that is curved in the z-axis and body cross-sections that are circular, so there is a separate function for converting DWBA shapes:</p> <pre><code>from echosms import outline_from_dwba, DWBAdata, plot_specimen\nimport uuid\nfrom datetime import datetime, timezone\n\n# Get a krill shape from the old echoSMs DWBA datastore\ndata = DWBAdata()\nkrill = data.model('Generic krill (McGehee 1998)')\nkrill.plot()\n\n# Convert the shape to the echoSMs anatomical datastore form.\ns = outline_from_dwba(x = krill.rv_pos[:, 0],\n                      z = -krill.rv_pos[:, 2],\n                      radius = krill.a,\n                      anatomical_feature='body',\n                      boundary='fluid-filled')\n\n# Add in other shape attributes to give enough information to run a model.\ns['sound_speed_ratio'] = krill.h\ns['mass_density_ratio'] = krill.g\n\n# The shape is now in the echoSMs anatomical datastore form with\n# (x,y,z) points defining the centreline and widths and heights for\n# the body size.\nprint(s.keys())\n\n# Add the shape to some example specimen metadata\nspecimen = {'uuid': str(uuid.uuid4()),\n            'specimen_name': '123',\n            'version_number': 1,\n            'version_time': datetime.now(timezone.utc).isoformat(),\n            'version_note': 'Initial version',\n            'description': ['Testing'],\n            'anatomical_category': 'organism',\n            'aphia_id': 1234,\n            'date_collection': 'unknown',\n            'date_image': 'unknown',\n            'imaging_method': 'radiograph',\n            'shape_method': 'unknown',\n            'straightened': True,\n            'smoothed': False,\n            'rotated': False,\n            'dataset_size': 1.0,\n            'dataset_units': 'megabyte',\n            'specimen_condition': 'unknown',\n            'length': 0.0,\n            'length_units': 'm',\n            'length_type': 'unknown',\n            'shape_type': 'outline',\n            'shapes': [s]}\n\n# And use an echoSMs function to plot the shape \n# (to compare to the one from DWBAdata above()).\nplot_specimen(specimen)\n</code></pre>"},{"location":"datastore_anatomical/#voxels","title":"Voxels","text":"<p>The <code>voxels</code> format contains two 3D matrices, one for density and one for sound speed. The echoSMs representation of a 3D matrix is a doubly-nested list as used by the Numpy package. Rows (numpy axis 0) correspond to the echoSMs z-axis, columns (numpy axis 1) to the echoSMs x-axis, and slices (numpy axis 2) to the echoSMs y-axis.</p> <p>Numpy's <code>tolist()</code> method is used to convert between a Python numpy 3D matrix and the echoSMs structure:</p> <p><pre><code>import numpy as np\n\n# Get 3D matrices of sound speed and density\nrho = np.array([...])\nc = np.array([...])\n\n# Put into a dict as per the echoSMs datastore schema\nshape = {'voxel_size': [0.005, 0.005, 0.005],\n         'voxel_size_units': 'm',\n         'mass_density': rho.tolist(),\n         'mass_density_units': 'kg/m^3',\n         'sound_speed_compressional': c.tolist(),\n         'sound_speed_compressional_units': 'm/s'}\n</code></pre> If using Xarrays rather than Numpy, you'll need to use the Xarray <code>.values</code> attribute to get the Numpy matrix and then call <code>tolist()</code>:</p> <pre><code>shape = {'voxel_size': [0.005, 0.005, 0.005],\n         'voxel_size_units': 'm',\n         'mass_density': rho.values.tolist(),\n         'mass_density_units': 'kg/m^3',\n         'sound_speed_compressional': c.values.tolist(),\n         'sound_speed_compressional_units': 'm/s'}\n</code></pre>"},{"location":"datastore_anatomical/#categorised-voxels","title":"Categorised voxels","text":"<p>The <code>categorised voxels</code> format uses a single 3D matrix of material property categories (named <code>categories</code> in the schema) - for echoSMs these categories must be integers starting at 0. The categories define regions of homogenous material properties in the specimen. The category value is used as a zero-based index into associated <code>mass_density</code> and <code>sounds_speed_compressional</code> vectors. Hence, the length of the density and sound speed arrays must be at least one more than the highest category number in <code>categories</code>. The category matrix is structured the same way as for the voxels format (see above).</p>"},{"location":"datastore_intro/","title":"Introduction","text":"<p>The echoSMs datastore is an online repository of acoustic scattering model input data.</p> <p>The purpose is to:</p> <ol> <li>Provide an open and accessible repository of anatomical fish and plankton data for use in acoustic scattering models,</li> <li>Facilitate standardisation of data formats and metadata relevant to acoustic scattering model inputs,</li> <li>Provide a web-accessible API for searching and accessing anatomical and model data,</li> <li>Provide a web-based user interface for browsing, searching, uploading, and downloading datasets.</li> </ol> <p>While the datastore is part of the echoSMs scattering model code base, it is not restricted to only being used with that code. The design and access method is sufficiently generic that any scattering model code can access and use the shapes and metadata.</p> Note <p>The datastore is under active development and we welcome feedback on all aspects of it. We are especially interested in whether the metadata is appropriate and sufficient, the web API is convenient to use, and in any other comments you may have with regards to the datastore's purpose and structure.</p>"},{"location":"datastore_models/","title":"Using datastore shapes with echoSMs","text":"<p>This section contains examples of using echoSMs datastore data.</p>"},{"location":"datastore_models/#calculating-ts-from-a-datastore-specimen","title":"Calculating TS from a datastore specimen","text":"<p>Here is an example of getting model shapes from the datastore and estimating the target strength using an echoSMs model.</p> <pre><code>import echosms\nimport requests\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# The current location of the echoSMs datastore server\nbaseURI = 'https://echosms-data-store-app-ogogm.ondigitalocean.app/'\n\n# Create an instance of the echoSMs KRM model for use below\nm = echosms.KRMModel()\n\n# Get all the datastore organisms from the CLAY_HORNE dataset.\n# This returns the metadata about the specimens but no shape information.\nr = requests.get(baseURI + 'v2/specimens/?dataset_id=CLAY_HORNE')\n\nfor o in r.json():\n    print(f'Processing specimen {o[\"specimen_id\"]} from the {o[\"dataset_id\"]} dataset')\n\n    # Get the organism data (including the shape) from the datastore\n    r = requests.get(baseURI + 'v2/specimen/' + o['id'] + '/data')\n    if r.status_code != 200:\n        print(f'Request for data from specimen {o[\"id\"]} failed - skipping')\n        continue\n\n    # Get the model data out of the requests object\n    s = r.json()\n\n    # Assemble the echoSMs model parameters\n    p = {'medium_c': 1500,  # [m/s]\n         'medium_rho': 1024,  # [kg/m^3]\n         'theta': 90.0,  # [deg] dorsal aspect\n         'f': np.arange(10, 201, 1)*1e3,  # [Hz]\n         'organism': echosms.krmorganism_from_datastore(s['shapes'])}\n\n    # Calculate the TS using those parameters\n    ts = m.calculate_ts(p)\n\n    # Add to a plot of all the TS results\n    plt.plot(p['f']*1e-3, ts, label=s['specimen_id'])\n\nplt.legend(title='Specimens')\nplt.title('Dataset ' + s['dataset_id'])\nplt.xlabel('Frequency [kHz]')\nplt.ylabel('TS [dB re 1 m$^2$]')\nplt.show()\n</code></pre>"},{"location":"datastore_models/#converting-between-from-echosms-shapes","title":"Converting between from echoSMs shapes","text":""},{"location":"datastore_models/#surface-to-outline","title":"Surface to outline","text":"<p>This code shows how to load an STL 3D triangular mesh and convert it into an echoSMs outline shape. It can then be used with echoSMs models that use outlines (e.g., KRM, DWBA).</p> <pre><code>from echosms import surface_to_outline, surface_from_stl, plot_specimen\n\n# Load a example STL file (you'll need to provide your own)\nshape = surface_from_stl('length_44_cm_body.stl',\n                          dim_scale=1.0,\n                          anatomical_type='body',\n                          boundary='pressure-release')\n\n# Flip the STL mesh around to fit the echoSMs coordinate system.\n# This step will depend on how your mesh is oriented\nx = shape['x']\ny = shape['y']\nz = shape['z']\n\n# The shape is centered on the y and z axis\nshape['x'] = [-v for v in z]\nshape['y'] = [v- sum(x)/len(x)  for v in x]\nshape['z'] = [v- sum(y)/len(y)  for v in y]\n\n# Add the shape into an echoSMs specimen metadata structure so it can\n# be plotted using the echoSMs plot_specimen() function\nspecimen = {'specimen_id': 'A',\n            'specimen_condition': 'fresh',\n            'length': 0.044,\n            'length_units': 'm',\n            'length_type': 'total length',\n            'shape_type': 'surface',\n            'shapes': [shape]}\n\nplot_specimen(specimen)\n\n# Do the conversion. For the moment, this function expects an echoSMs\n# shape data structure but it may be more convenient for it to accept\n# an echoSMs specimen data structure.\n# Note: the particulars of how the metadata are structured may change\n# as the datastore data structures are refined.\nshape = surface_to_outline(specimen['shapes'][0], slice_thickness=0.005)\n\n# Update the specimen metadata structure with the outline shape\nspecimen['shape_type'] = 'outline'\nspecimen['shapes'] = [shape]\n\nplot_specimen(specimen)\n\n# It's not shown here, but the next steps are to use krmorganism_from_datastore()\n# or dwba_from_datastore() to convert the shape into the form that the relevant\n# echoSMs models require.\n</code></pre>"},{"location":"datastore_models/#outline-to-surface","title":"Outline to surface","text":"<p>This code shows how to convert an echoSMs outline shape into an echoSMs surface shape, using a shape from the echoSMs anatomical datastore.</p> <pre><code>import requests\nfrom echosms import outline_to_surface, plot_specimen\n\n# Get an outline shape from the echoSMs anatomical datastore\nbaseURI = 'https://echosms-data-store-app-ogogm.ondigitalocean.app/'\nr = requests.get(baseURI + 'v2/specimen/CLAY_HORNE_B/data')\nspecimen = r.json()\n\n# Plot the outline shapes - there will be a body and swimbladder shape\nplot_specimen(specimen)\n\n# Convert the shapes to surfaces.\n# For the moment, outline_to_surface expects an echoSMs shape data\n# structure but it may be more convenient for it to accept an echoSMs\n# specimen data structure.\nsurfaces = []\nfor shape in specimen['shapes']:\n    surfaces.append(outline_to_surface(shape))\n\n# And update the specimen dict with the shapes and shape type\nspecimen['shapes'] = surfaces\nspecimen['shape_type'] = 'surface'\n\n# Plot the surface shapes\nplot_specimen(specimen)\n</code></pre>"},{"location":"developing/","title":"Developing echoSMs","text":"<p>These notes are a work in progress.</p> <p>This page contains notes and instructions on developing and adding new models to echoSMs.</p>"},{"location":"developing/#obtaining-the-source-code","title":"Obtaining the source code","text":"<p>The echoSMs source code is kept on github under an ICES account. Clone the repository with this URL:</p> <pre><code>https://github.com/ices-tools-dev/echoSMs.git\n</code></pre>"},{"location":"developing/#coding-guidelines","title":"Coding guidelines","text":"<p>We want echoSMs to be a software package that is easy to maintain, understand, use, and to have lasting value. To help achieve this we aim for the following:</p> <ul> <li>clear and complete documentation</li> <li>good example code to help learn how to use echoSMs</li> <li>scattering model code that closely follows the terminology and structure of the papers that the models are implemented from</li> <li>a preference for clear code over computational efficiency</li> <li>minimial dependencies on other software (e.g., other Python packages)</li> </ul>"},{"location":"developing/#style","title":"Style","text":"<p>Contributions of code should follow standardised or community-agreed styles and be provided in (or added to) a structure suitable for packaging and uploading to package libraries. For Python this includes <code>pip</code> and/or <code>conda</code>, for R this would be <code>CRAN</code>, for Matlab this would be a toolbox on the MATLAB File Exchange, etc.</p> <p>Python code should follow PEP8 and docstrings should use PEP257 with the contents following the numpydoc style. An exception to PEP8 is made to allow lines of up to 100 characters.</p>"},{"location":"developing/#generating-packages-for-pypi","title":"Generating packages for PyPI","text":"<p>EchoSMs is a pure Python package. The build configuration is done via a pyproject.toml file and <code>hatchling</code> is used to produce packages.</p> <p>A github action in the echoSMS repository will generate a Python wheel and source package and upload these to PyPI. This action is triggered whenever a tagged commit occurs to the repository. The tag is used as the new version number. EchoSMs version numbers follow the semantic versioning convention.</p> <p>Every commit to the echoSMs repository will generate a development package being uploaded to TestPyPI. This is used to always check that a commit does not prevent production of a package and is where a package containing the latest commit can be obtained.</p>"},{"location":"developing/#documentation","title":"Documentation","text":"<p>The echoSMs documentation is produced using <code>mkdocs</code> and <code>mkdocstrings</code>. The documentation pages are hosted by github and are regenerated after every commit to the repository using a github action.</p> <p>Documentation edits can be tested locally by running:</p> <pre><code>mkdocs serve\n</code></pre> <p>in the top level of the echoSMs repository. The documentation is then available at http://127.0.0.1:8000.</p>"},{"location":"developing/#tests","title":"Tests","text":"<p>EchoSMs uses the pytest testing framework. After installing pytest, run the tests using</p> <pre><code>pytest -v\n</code></pre> <p>in the top level of the echoSMs repository.</p>"},{"location":"developing/#adding-a-new-scattering-model","title":"Adding a new scattering model","text":"<p>TBD.</p>"},{"location":"historical_notes/","title":"Historical code and notes","text":""},{"location":"historical_notes/#krm-code-from-clay-horne-1994","title":"KRM code from Clay &amp; Horne (1994)","text":"<p>The original Basic language code for the KRM model (Kirchhoff Ray Mode) is available as part of echoSMs here. Also included there are the original shape data for the four cod fish used in the paper.</p>"},{"location":"historical_notes/#psms-code-from-furusawa-1988","title":"PSMS code from Furusawa (1988)","text":"<p>The HP Basic language code for the PSMS model (Prolate Spheroidal Modal Series) is available as part of echoSMs here. Also included is a modified version of the code that can run on a Windows computer with HTBasic.</p>"},{"location":"historical_notes/#matlab-code-from-chu","title":"Matlab code from Chu","text":"<p>Various scattering model codes, written in Matlab, were provided by Dezhang Chu. These are included as part of echoSMs here.</p>"},{"location":"other_software/","title":"Other software","text":"<p>Software that provides source code for acoustic scattering models of relevance to fisheries and plankton acoustics are listed below. A more general list of underwater acoustic modelling software is available at the Ocean Acoustics Library.</p> <ul> <li>acousticTS: R code for calculating scattering using the DCM, DWBA, SDWBA, SDWBA_curved, KRM, MSS model, as well as that of calibration spheres.</li> <li>Coupled BEM acoustic: Julia code that calculates the TS of three-dimensional shapes with an included object (e.g., a swimbladder).</li> <li>FishAcoustics: Contains a Python module that implements the phase-tracking DWBA model.</li> <li>gasbubbles: Contains Python code for scattering models relevant to gas bubbles. Uses echoSMs for some of its' models.</li> <li>Hydrac: Contains Python code that implements several exact and approximate scattering models, including the DWBA and high-pass models. Hydrac is a package for computing suspended matter concentrations from backscatter.</li> <li>KRM Model: A web page that uses the KRM model to estimate the TS of predefined or user-supplied shapes over a range of input parameters.</li> <li>KRMr: KRM model for fish in R.</li> <li>Liquid spheroid: Julia and C++ code to calculate the scattering by fluid prolate and oblate spheroids.</li> <li>MM-BEM, github: Code in various languages/systems (C, Python, Matlab, Julia, BEMpp, gypsilab, and FreeFem) that implement the boundary element method for scattering.</li> <li>Prol_Spheroid: Python and Fortran code to calculate the scattering from liquid and gas-filled prolate spheroids.</li> <li>scatmod: Open source acoustic scattering models for fisheries acoustics. Python and R code for fluid spheres.</li> <li>SDWBA Model: A web page that uses the SDWBA model to estimate the TS of predefined shapes over a range of input parameters.</li> <li>SDWBA packages: Provides krill model data</li> <li>SDWBA.jl: Julia code that implements the SDWBA model</li> <li>SDWBA.py: Unfinished Python code to implement the SDWBA model.</li> <li>SDWBA.R: Untested R code that implements the SDWBA model.</li> <li>SDWBA_TS: Matlab code that implements the SDWBA model for Antarctic krill.</li> <li>sphereTS: Python code to calculate the TS of calibration spheres.</li> <li>Standard sphere target strength calculator: A web page that calculates the TS of calibration spheres.</li> <li>tetrascatt: R and C++ code that implements the DWBA model on arbitrary geometries.</li> <li>ZooScatR: R code that implements the DWBA model.</li> </ul>"},{"location":"training/","title":"Training resources","text":"<p>This section is under development</p> <p>Choosing and using acoustic scattering models can be difficult. To help, this page provides links  to some helpful resources and presentations. Suggestions of additional items for the list below are welcome, as are other training materials that may be relevant.</p> <ul> <li>An overview of scattering models types and uses</li> <li>The echoSMs presentation to the 2025 meeting of the ICES FAST working group</li> <li>The Jupyter notebook used during the 2025 echoSMS WG-FAST presentation</li> <li>The presentation to the echoSMs workshop held during the 2025 WG-FAST meeting</li> <li>The Jupyter notebook used during the 2025 echoSMS WG-FAST workshop</li> </ul>"},{"location":"usage/","title":"Using echoSMs","text":"<p>EchoSMs is (currently) a Python package that implements acoustic scattering models. Each different model is a separate Python class in the echoSMs package. They all inherit from a common base class that defines a common calling convention.</p>"},{"location":"usage/#installation","title":"Installation","text":"<p>EchoSMs is available on PyPi as <code>echosms</code>. Install it with:</p> <pre><code>pip install echosms\n</code></pre>"},{"location":"usage/#versions","title":"Versions","text":"<p>The changelogs for echoSMs are listed here and the latest release is always at the top of that list.</p> <p>The installed version of echosms can be printed with this Python code:</p> <pre><code>from importlib.metadata import version\nversion('echosms')\n</code></pre> <p>To upgrade echosms to the latest version use:</p> <pre><code>pip install echosms --upgrade\n</code></pre>"},{"location":"usage/#model-overview","title":"Model overview","text":"<p>The following models are available in echoSMs:</p> Model type Python class name(s) Description Deformed cylinder DCMModel Truncated cylinders with various boundary conditions Distorted-wave Born approximation DWBAModel Weakly scattering objects with piecewise circular cross-sections and homogenous interiors with an optional stochastic variant (the SDWBA) Elastic sphere ESModel Elastic spheres, such as echosounder calibration spheres High-pass HPModel Approximate models for simple shapes Kirchhoff approximation KAModel Surfaces that are mainly convex Kirchhoff ray mode KRMModel A fish body and swimbladder model for high and low frequencies Modal series solution MSSModel Spheres with various boundary conditions, including shells Prolate spheroidal modal series PSMSModel Prolate spheroids with various boundary conditions Phase-tracking distorted-wave Born approximation PTDWBAModel Weakly scattering objects of any shape with inhomogeneous interiors <p>Future models will include the Fourier matching method and potentially the finite element and boundary element models. We welcome contributions or suggestions of additional models.</p>"},{"location":"usage/#running-a-model","title":"Running a model","text":"<p>Each echoSMs model expects input parameters that define the model (e.g., size, shape, material properties, etc). These can be provided in three ways:</p> <ul> <li>A Python dictionary with an entry for each parameter,</li> <li>A Pandas DataFrame with columns for each parameter and a row for each model run,</li> <li>An Xarray DataArray with as many dimensions as parameters. The parameter values are in the DataArray coordinate variables.</li> </ul> <p>To use a model, you need to know what parameters it requires. These are documented in the <code>calculate_ts_single</code> function that each model has (refer to the echoSMS API reference for details). The units for numerical parameters will always follow the echoSMs unit convention. For example, the MSSModel, when simulating the scattering from a pressure release sphere, needs the following parameters:</p> Name Description medium_c Sound speed in the fluid medium surrounding the target [m/s] medium_rho Density of the fluid medium surrounding the target [kg/m\u00b3] a Radius of the spherical target [m] f Frequency to calculate the scattering at [Hz] boundary_type The boundary type. Supported types are <code>fixed rigid</code>, <code>pressure release</code>, and <code>fluid filled</code> <p>The simplest way to provide these to the model is a dictionary:</p> <pre><code>p = {'medium_rho': 1026.8,\n     'medium_c': 1477.4,\n     'a': 0.01, \n     'boundary_type': 'pressure-release',\n     'f': 38000}\n</code></pre> <p>An instance of the model can then be created and the <code>calculate_ts</code> function called with these parameters:</p> <pre><code>from echosms import MSSModel\nmodel = MSSModel()\nmodel.calculate_ts(p)\n</code></pre> <p>This will return one TS value corresponding to the parameters given. If you want to run the model for a range of parameters, the relevant dictionary items can contain multiple values:</p> <pre><code>import numpy as np\np = {'medium_rho': 1026.8,\n     'medium_c': 1477.4,\n     'a': 0.01,\n     'boundary_type': 'pressure-release',\n     'f': np.arange(10, 100, 1)*1000}  # [Hz]\nmodel.calculate_ts(p)\n</code></pre> <p>It is also fine to have multiple items with multiple values:</p> <pre><code>p = {'medium_rho': 1026.8,\n     'medium_c': 1477.4,\n     'a': np.arange(0.01, 0.02, 0.001),  # [m]\n     'boundary_type': ['pressure-release', 'fixed-rigid'],\n     'f': np.arange(10, 100, 1)*1000}  # [Hz]\nmodel.calculate_ts(p)\n</code></pre> <p>The TS will be calculated for all combinations of the parameters. To do this, echoSMs expands the parameters into a Pandas DataFrame with one column for each parameter and one row for each of the combinations. It then runs the model on each row of the DataFrame. That DataFrame, with the TS included, can be returned instead of a list of TS values by using the <code>expand</code> option:</p> <pre><code>model.calculate_ts(p, expand=True)\n</code></pre> <p>An introductory Jupyter notebook is available that covers the above concepts and a Python script that covers this and more is available here.</p>"},{"location":"usage/#using-dataframes-and-dataarrays-directly","title":"Using DataFrames and DataArrays directly","text":"<p>Instead of passing a dictionary to the <code>calculate_ts</code> function, a DataFrame or DataArray can be passed instead. The crucial aspect is that the DataFrame columns must have the same names as the parameters that the model requires. For a DataArray, the coordinate dimensions must have the same names as the model parameters.</p> <p>EchoSMS provides two utility functions (<code>as_dataframe</code>, and <code>as_dataarray</code>) to convert from a dictionary representation of model parameters to a DataFrame or DataArray, or you can construct your own, or modify those returned by the <code>as_dataframe</code> and <code>as_dataarray</code> functions.</p> <p>The benefit of using a DataFrame is that you have fine control over what model runs will happen - it doesn't have to be the full set of combinations of input parameters. The benefit of using a DataArray is that it is easy to extract subsets of the results for further analysis and plotting.</p> <p>For a DataFrame, the number of model runs will be the number of rows in the DataFrame. For a DataArray the number of models run will be the size of the DataArray (e.g., <code>DataArray.size()</code>)</p> <p>When passing a DataFrame to a model, you can choose whether the TS results are returned as a <code>Series</code> or are added to the existing DataFrame (in a column called <code>ts</code>). Use the <code>inplace = True</code> parameter in the call to <code>calculate_ts</code> for this. When passing a DataArray to a model, the TS results are always returned in the data part of the passed in DataArray.</p>"},{"location":"usage/#more-complex-model-parameters","title":"More complex model parameters","text":"<p>Some models use parameters that are not sensibly duplicated across rows in a DataFrame or as a dimension in a DataArray (e.g., the data that specifies the three-dimensional shape of a fish swimbladder). EchoSMs allows for this with the concept of non-expandable parameters - these are not expanded into DataFrame columns or DataArray dimensions. Non-expandable parameter names are available from the models' <code>no_expand_parameters</code> attribute.</p> <p>But, as it is very convenient to have all the model parameters in one data structure, echoSMs will store the non-expandable parameters as a dict in the DataFrame or DataArray attributes. An example of this is the <code>PTDWBAModel</code>:</p> <pre><code>from echosms import PTDWBAModel, as_dataframe\nimport numpy as np\n\nmodel = PTDWBAModel()\n\nm = {'volume': np.full((5,5,5), 0),\n     'f': np.arange(10, 100, 1)*1000,\n     'rho': [1024, 1025],  \n     'c': [1500, 1501],\n     'voxel_size': (0.001, 0.001, 0.001),\n     'theta': 90,\n     'phi': 0}\nm['volume'][3,3,3] = 1  # something to produce scatter\n\np = as_dataframe(m, model.no_expand_parameters)\nmodel.calculate_ts(p, inplace=True)\nprint(p)\n</code></pre> <p>For the PTDWBA model, only <code>theta</code> and <code>phi</code> are expandable, so <code>p</code> contains three columns (<code>theta</code>, <code>phi</code>, and <code>ts</code>). The remaining parameters are available via:</p> <pre><code>p.attrs['parameters']\n</code></pre> <p>Note that while <code>rho</code> and <code>c</code> look like parameters that would be expanded, they are in the list of non-expandable parameters, so are not expanded. This is because the structure of the PTDWBA model means that it it not sensible to have variable parameters for <code>rho</code> and <code>c</code>. </p> <p>If you pass the dictionary form of the parameters to a model, this treatment of non-expanding parameters is done automatically, where</p> <pre><code>model.calculate_ts(m, expand=True)\n</code></pre> <p>returns the same results as</p> <pre><code>p = as_dataframe(m, model.no_expand_parameters)\nmodel.calculate_ts(p, inplace=True)`\nprint(p)\n</code></pre>"},{"location":"usage/#multiprocessing","title":"Multiprocessing","text":"<p>EchoSMs can use more than one CPU to run models. Internally, echoSMs uses a Pandas DataFrame to store the parameters for each model run (one row per parameter set) and the multiprocessing is achieved with a package that runs an echoSMs model on each row in the DataFrame, split across separate CPUs. This is enabled with the <code>multiprocess = True</code> parameter in the call to <code>calculate_ts()</code>. The total solution time will decrease almost linearly with the number of CPUs.</p> <p>A progress bar can be shown via the <code>progress = True</code> option, but note that this tends to not work correctly in some Python terminals (e.g. the Spyder terminal). The progress bar shows the number of chunks that the DataFame has been split into and the number of chunks completed (in contrast, the non-multiprocessing progress bar shows the number of model runs completed).</p> <p>EchoSMs currently uses the mapply package to distribute the model runs. Mapply is limited to CPUs on the one computer - it does not support multiprocessing across multiple computers. A different multiprocessing package would be needed to support running on multiple computers (e.g. clusters of computers).</p>"},{"location":"usage/#reference-model-definitions","title":"Reference model definitions","text":"<p>Jech et al., (2015) presented reference models for a range of scattering objects: spheres, spherical shells, prolate spheroids, and finite cylinders for several boundary conditions (fixed rigid, pressure release, fluid-filled) and parameters (backscatter as a function of frequency and incident angle). These model definitions are included in echoSMs via the <code>ReferenceModels</code> class, along with other objects, such as calibration spheres. For example, the names of all the model definitions are available with:</p> <pre><code>from echosms import ReferenceModels\nrm = ReferenceModels()\nrm.names()\n</code></pre> <p>which returns:</p> <pre><code>['fixed rigid sphere',\n 'pressure release sphere',\n 'gas filled sphere',\n 'weakly scattering sphere',\n 'spherical fluid shell with pressure release interior',\n 'spherical fluid shell with gas interior',\n 'spherical fluid shell with weakly scattering interior',\n 'fixed rigid prolate spheroid',\n 'pressure release prolate spheroid',\n 'gas filled prolate spheroid',\n 'weakly scattering prolate spheroid',\n 'fixed rigid finite cylinder',\n 'pressure release finite cylinder',\n 'gas filled finite cylinder',\n 'weakly scattering finite cylinder',\n 'WC20 calibration sphere',\n 'WC21 calibration sphere',\n 'WC22 calibration sphere',\n 'WC25 calibration sphere',\n 'WC38.1 calibration sphere',\n 'WC57.2 calibration sphere',\n 'WC60 calibration sphere',\n 'WC64 calibration sphere',\n 'Cu13.7 calibration sphere',\n 'Cu23 calibration sphere',\n 'Cu32 calibration sphere',\n 'Cu42 calibration sphere',\n 'Cu45 calibration sphere',\n 'Cu60 calibration sphere',\n 'Cu63 calibration sphere',\n 'Cu64 calibration sphere']\n</code></pre> <p>and the specification for a particular model is given by:</p> <pre><code>rm.specification('spherical fluid shell with weakly scattering interior')\n</code></pre> <p>which returns:</p> <pre><code>{'name': 'spherical fluid shell with weakly scattering interior',\n 'shape': 'sphere',\n 'boundary_type': 'fluid shell fluid interior',\n 'description': 'A fluid spherical shell with a weakly scattering shell and interior',\n 'a': 0.01,\n 'shell_thickness': 0.001,\n 'medium_rho': 1026.8,\n 'medium_c': 1477.4,\n 'shell_rho': 1028.9,\n 'shell_c': 1480.3,\n 'target_rho': 1031.0,\n 'target_c': 1483.3,\n 'source': 'https://doi.org/10.1121/1.4937607',\n 'benchmark_model': 'mss'}\n</code></pre> <p>Note that the specification contains more information that the model itself needs, so the subset needed for running a model is available via:</p> <pre><code>m = rm.parameters('spherical fluid shell with weakly scattering interior')\nprint(m)\n</code></pre> <p>which returns:</p> <pre><code>{'boundary_type': 'fluid shell fluid interior',\n 'a': 0.01,\n 'shell_thickness': 0.001,\n 'medium_rho': 1026.8,\n 'medium_c': 1477.4,\n 'shell_rho': 1028.9,\n 'shell_c': 1480.3,\n 'target_rho': 1031.0,\n 'target_c': 1483.3}\n</code></pre> <p>Note that the <code>parameters()</code> call does not return all of the parameters needed by a model. For example, <code>f</code> is not there and needs to be added before running a model:</p> <pre><code>m['f'] = [38000, 40000, 42000]\n\nfrom echosms import MSSModel\nmodel = MSSModel()\nmodel.calculate_ts(m)\n</code></pre>"},{"location":"usage/#benchmark-model-ts","title":"Benchmark model TS","text":"<p>Jech et al., (2015) presented benchmark TS values for the reference models. The TS results from these benchmarks are available in echoSMs via the <code>BenchmarkData</code> class. This class reads the CSV-formatted files of benchmark values and provides methods that list the benchmark names, returns TS as a function of frequency and angle for each benchmark model. For more complex uses of the benchmark data, they are also available as Pandas DataFrames.</p> <pre><code>from echosms import BenchmarkData\nbm = BenchmarkData()\n\n# Lists of the benchmark model names\nbm.freq_names()\nbm.angle_names()\n\n# TS as a function of frequency for a model\nf, ts = bm.freq_data('fixed rigid sphere')\n\n# TS as a function of angle for a model\ntheta, ts = bm.angle_data('fixed rigid prolate spheroid')\n\n# As Pandas DataFrames\nbm.freq_as_dataframe()\nbm.angle_as_dataframe()\n</code></pre>"},{"location":"usage/#shape-viewer","title":"Shape Viewer","text":"<p>EchoSMs includes an optional graphical user interface (GUI) for inspecting organism shapes and anatomical data. This is particularly useful for verifying geometric models (like DWBA or KRM shapes) before running acoustic simulations.</p>"},{"location":"usage/#installation_1","title":"Installation","text":"<p>The viewer requires additional dependencies. To install echoSMs with the viewer support:</p> <pre><code>pip install echosms[viewer]\n</code></pre>"},{"location":"usage/#usage","title":"Usage","text":"<p>Once installed, you can launch the viewer from the command line:</p> <pre><code>echosms-view\n</code></pre> <p>The Shape Viewer allows you to:</p> <ul> <li>Load Shapes: Browse models directly from the echoSMs DataStore (via the web) or open local JSON/TOML files.</li> <li>Inspect Geometry: Switch between 2D profile views and 3D wireframe reconstructions to check coordinate alignment and structural integrity.</li> <li>Verify Metadata: View detailed metadata associated with each shape to ensure the correct species and dimensions are being used.</li> </ul>"},{"location":"schema/data_store_schema/","title":"EchoSMs anatomical datastore schema","text":"<p>This schema defines a structure for storing fish and plankton acoustic scattering model data, mainly for input to the echoSMs anatomical datastore.</p> <p>The reference version of the schema (formatted as a JSON-schema file) will always be available in the echoSMs github repository.</p>"},{"location":"schema/data_store_schema/#specimen","title":"Specimen","text":"<p>The specimen properties are:</p> Property Required Description Type Constraints uuid yes A Universally Unique IDentifier for this specimen as per RFC9562. Generated by the datastore. string version_number yes A version number that increments whenever this specimen is updated. Generated and updated by the datastore. integer minimum: 1 version_time yes The timestamp when this specimen dataset was last modified, in RFC9557 format, including the timezone. Generated and updated by the datastore. string version_note yes A note about the changes in this version. string version_investigators no Names or identifying descriptions of persons or organisations that updated or created this dataset. array of string dataset_uuid no A Universally Unique IDentifier for a dataset as RFC9562. Datasets are used only to group multiple specimens together. They contain no information that is not already in the specimen metadata. string dataset_name no A name for the dataset. string description yes A description of the specimen. array of string anatomical_category yes The type of anatomy that this dataset contains. enum of string one of <code>tissue</code>, <code>organ</code>, <code>organ system</code>, <code>organism</code>, <code>other</code> aphia_id yes The WoRMS aphiaID of the species in this dataset. integer minimum: 1 class no Taxonomical hierarchy level of class that is consistent with WoRMS. string order no Taxonomical hierarchy level of order that is consistent with WoRMS. string family no Taxonomical hierarchy level of family that is consistent with WoRMS. string genus no Taxonomical hierarchy level of genus that is consistent with WoRMS. string species no Taxonomical hierarchy level of species that is consistent with WoRMS. string vernacular_names no Vernacular names for the organism. array of string reference no A literature reference for the dataset. If available, a DOI or URI is recommended. string activity_name no Name of the data collection activity (if any), such as voyage code, project name, etc. string location no Name or description of the location where organism was collected. string latitude no Latitude of location where organism was collected. number minimum: -90maximum: 90 latitude_units yes, if <code>latitude</code> is present Units for latitude. Positive values indicate north of the equator. enum of string must be: <code>degrees_north</code> longitude no Longitude of location where organism was collected. number minimum: -180maximum: 180 longitude_units yes, if <code>longitude</code> is present Units for longitude. Positive values indicate east of the prime meridian. enum of string must be: <code>degrees_east</code> depth no Depth below surface of organism collection location. number minimum: 0 depth_units yes, if <code>depth</code> is present Units for depth. enum of string must be: <code>m</code> date_collection yes The date or date range when the dataset was collected, in RFC9557 format. string date_image yes The date when the dataset was imaged, in RFC9557 format. string data_collection_description no Description of data collection details. string notes no Explanatory notes about the shape data. array of string imaging_method yes Method used to obtain the raw image data. enum of string one of <code>radiograph</code>, <code>CT</code>, <code>MRI</code>, <code>photograph</code>, <code>3D scanner</code>, <code>unknown</code>, <code>other</code>, <code>not applicable</code> shape_method yes Method used to obtain the specimen shape. enum of string one of <code>manual outline of image(s)</code>, <code>automated outline of images(s)</code>, <code>3D scan of object</code>, <code>not applicable</code>, <code>unknown</code>, <code>other</code> shape_method_processing no Description of processing used to convert raw images into shapes, including any manipulation of image data (for example, smoothing, edge enhancement, rotation, etc). string straightened yes Was the shape straightened during the processing. boolean smoothed yes Was the shape smoothed during the processing. boolean rotated yes Was the shape rotated during the processing. boolean model_type no Original scattering model type. enum of string one of <code>KRM</code>, <code>KA</code>, <code>DWBA</code>, <code>PTDWBA</code>, <code>FEM</code>, <code>BEM</code>, <code>MFS</code>, <code>other</code>, <code>unknown</code>, <code>none</code> sound_speed_method no Method used to obtain sound speed in the feature. enum of string one of <code>density to sound speed relationship</code>, <code>time-of-flight</code>, <code>literature</code>, <code>unknown</code>, <code>other</code> mass_density_method no Method used to obtain density in the feature. enum of string one of <code>CT density</code>, <code>liquid displacement</code>, <code>literature</code>, <code>unknown</code>, <code>other</code> dataset_size yes Size of the entire dataset (including raw data). Generated by the datastore server. number minimum: 0 dataset_size_units yes Units for dataset_size. Generated by the datastore server. enum of string must be: <code>megabyte</code> radiograph_perspective no The viewpoint of the imaging x-ray machine to the anatomical feature. enum of object one of <code>lateral</code>, <code>dorsal</code>, <code>other</code> radiograph_exposure_time no The exposure time setting of the imaging x-ray machine. string radiograph_exposure_time_unit no Unit of exposure time. enum of string must be: <code>s</code> radiograph_focal_length no Focal length setting of the imaging x-ray machine. string radiograph_focal_length_unit no Unit of focal length. enum of string must be: <code>m</code> radiograph_kVp no The kilovoltage peak setting of the imaging x-ray machine. number radiograph_mA no The milliamperage setting of the imaging x-ray machine. number specimen_name yes A name that identifies the specimen. string specimen_condition yes Condition of the specimen when it was imaged. enum of string one of <code>fresh</code>, <code>frozen</code>, <code>thawed</code>, <code>unknown</code>, <code>other</code> length yes Length of the specimen. number minimum: 0 length_units yes Units for lengths, dimensions, and sizes. enum of string must be: <code>m</code> weight no Weight of the specimen. number minimum: 0 weight_units yes, if <code>weight</code> is present Units for weight. enum of string must be: <code>kg</code> sex no Sex of specimen enum of string one of <code>female</code>, <code>male</code>, <code>immature</code>, <code>unknown</code> length_type yes Type of length measurement. enum of string one of <code>total length</code>, <code>fork length</code>, <code>standard length</code>, <code>lower jaw fork length</code>, <code>total width</code>, <code>carapace length</code>, <code>curved fork length</code>, <code>disc width</code>, <code>stretched total length</code>, <code>CCAMLR krill - front of eye to tip of telson</code>, <code>unknown</code>, <code>other</code> shape_type yes Type of shape data used for this specimen. enum of string one of <code>outline</code>, <code>surface</code>, <code>voxels</code>, <code>categorised voxels</code> shapes yes Shape data. Array of object minItems: 1"},{"location":"schema/data_store_schema/#shapes","title":"Shapes","text":"<p>The <code>shapes</code> properties are:</p> Property Required Description Type Constraints name no Name for the shape. string anatomical_feature yes Type of anatomical feature represented by this shape. enum of string one of <code>body</code>, <code>swimbladder</code>, <code>backbone</code>, <code>bone</code>, <code>muscle</code>, <code>head</code>, <code>eye</code>, <code>organs</code>, <code>appendages</code>, <code>inclusion</code>, <code>other</code> <p>and includes these properties as per the value of <code>shape_type</code></p> <code>outline</code><code>surface</code><code>voxels</code><code>categorised voxels</code> Property Required Description Type Constraints shape_units yes Units for lengths, dimensions, and sizes. enum of string must be: <code>m</code> boundary yes Type of reflecting boundary for this shape. enum of string one of <code>fixed-rigid</code>, <code>pressure-release</code>, <code>fluid-filled</code>, <code>elastic</code> x yes x-coordinate of shape centreline. array of number minItems: 1 y yes y-coordinate of shape centreline. array of number minItems: 1 z yes z-coordinate of shape centreline. array of number minItems: 1 height yes Height of the shape at each centreline point. array of number minItems: 1minimum: 0 width yes Width of the shape at each centreline point. array of number minItems: 1minimum: 0 mass_density no Mass density of shape. array of number minItems: 1minimum: 0 mass_density_units yes, if <code>mass_density</code> is present Units for mass density. enum of string must be: <code>kg/m^3</code> sound_speed_compressional no Compressional sound speed in shape. array of number minItems: 1minimum: 0 sound_speed_compressional_units yes, if <code>sound_speed_compressional</code> is present Units for sound speed. enum of string must be: <code>m/s</code> sound_speed_shear no Transversal (shear) sound speed in shape. array of number minItems: 1minimum: 0 sound_speed_shear_units yes, if <code>sound_speed_shear</code> is present Units for sound speed. enum of string must be: <code>m/s</code> mass_density_ratio no Ratio of mass densities of the shape and the surrounding material or shape. array of number minItems: 1minimum: 0 sound_speed_ratio no Ratio of compressional sound speed of the and the surrounding material or shape. array of number minItems: 1minimum: 0 youngs_modulus no Young's modulus, E, of the shape. array of number minItems: 1minimum: 0 youngs_modulus_units yes, if <code>youngs_modulus</code> is present Units for Young's modulus. enum of string must be: <code>Pa</code> Property Required Description Type Constraints shape_units yes Units for lengths, dimensions, and sizes. enum of string must be: <code>m</code> boundary yes Type of reflecting boundary for this shape. enum of string one of <code>fixed-rigid</code>, <code>pressure-release</code>, <code>fluid-filled</code>, <code>elastic</code> x yes x-coordinates of surface nodes. array of number minItems: 1 y yes y-coordinates of surface nodes. array of number minItems: 1 z yes z-coordinates of surface nodes. array of number minItems: 1 facets_0 yes Zero-based indices into x, y, and z that define node 0 of a surface triangle. array of integer minItems: 1minimum: 0 facets_1 yes Zero-based indices into x, y, and z that define node 1 of a surface triangle. array of integer minItems: 1minimum: 0 facets_2 yes Zero-based indices into x, y, and z that define node 2 of a surface triangle. array of integer minItems: 1minimum: 0 normals_x yes x-component of outward-pointing normal vector for each facet. array of number minItems: 1 normals_y yes y-component of outward-pointing normal vector for each facet. array of number minItems: 1 normals_z yes z-component of outward-pointing normal vector for each facet. array of number minItems: 1 mass_density no Mass density of shape. number minimum: 0 mass_density_units yes, if <code>mass_density</code> is present Units for mass density. enum of string must be: <code>kg/m^3</code> sound_speed_compressional no Compressional sound speed in shape. number minimum: 0 sound_speed_compressional_units yes, if <code>sound_speed_compressional</code> is present Units for sound speed. enum of string must be: <code>m/s</code> sound_speed_shear no Transversal (shear) sound speed in shape. number minimum: 0 sound_speed_shear_units yes, if <code>sound_speed_shear</code> is present Units for sound speed. enum of string must be: <code>m/s</code> mass_density_ratio no Ratio of mass densities of the shape and the surrounding material or shape. number minimum: 0 sound_speed_ratio no Ratio of compressional sound speed of the and the surrounding material or shape. number minimum: 0 youngs_modulus no Young's modulus, E, of the shape. number minimum: 0 youngs_modulus_units yes, if <code>youngs_modulus</code> is present Units for Young's modulus. enum of string must be: <code>Pa</code> Property Required Description Type Constraints voxel_size yes Voxel size, ordered x, y, z. array of number minItems: 3maxItems: 3minimum: 0 voxel_size_units yes Units for lengths, dimensions, and sizes. enum of string must be: <code>m</code> mass_density yes Mass density of voxels. array of array of array of number minItems: 1minItems: 1minItems: 1minimum: 0 mass_density_units yes Units for mass density. enum of string must be: <code>kg/m^3</code> sound_speed_compressional yes Compressional sound speed of voxels. array of array of array of number minItems: 1minItems: 1minItems: 1minimum: 0 sound_speed_compressional_units yes Units for sound speed. enum of string must be: <code>m/s</code> Property Required Description Type Constraints voxel_size yes Voxel size, ordered x, y, z. array of number minItems: 3maxItems: 3minimum: 0 voxel_size_units yes Units for lengths, dimensions, and sizes. enum of string must be: <code>m</code> categories yes Voxel categories array of array of array of integer minItems: 1minItems: 1minItems: 1minimum: 0 mass_density yes Mass density of voxels categories. array of number minItems: 1minimum: 0 mass_density_units yes Units for mass density. enum of string must be: <code>kg/m^3</code> sound_speed_compressional yes Compressional sound speed of voxel categories. array of number minItems: 1minimum: 0 sound_speed_compressional_units yes Units for sound speed. enum of string must be: <code>m/s</code>"}]}